;The MIT License
;
;Copyright (c) 2008-2012 Johan Kotlinski, Mats Andren
;
;Permission is hereby granted, free of charge, to any person obtaining a copy
;of this software and associated documentation files (the "Software"), to deal
;in the Software without restriction, including without limitation the rights
;to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
;copies of the Software, and to permit persons to whom the Software is
;furnished to do so, subject to the following conditions:
;
;The above copyright notice and this permission notice shall be included in
;all copies or substantial portions of the Software.
;
;THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
;IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
;FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
;AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
;LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
;OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
;THE SOFTWARE.

; ACME assembler

!cpu 6510
!to "durexforth.prg", cbm	; set output file and format

F_IMMED = $80
F_HIDDEN = $40
STRLEN_MASK = $3f

IP = $8a
TMP = $84
TMP2 = $86
TMP3 = $88

OP_JSR = $20
OP_RTS = $60
OP_LDA_I = $a9
OP_STA_AX = $9d

STACK_START = $84

; X = PSP
; SP = RSP

; kernal defs

CURSOR_BLINK = $cc ; 0 = enable; 1 = disable
CURSOR_TIMER = $cd
CURSOR_STATUS = $cf ; 0 = off; 1 = on

GETCHR = $ffe4 ; get char from kbd
PUTCHR = $ffd2 ; put char

; disk i/o
READST = $ffb7
SETLFS = $ffba
SETNAM = $ffbd
OPEN = $ffc0
CLOSE = $ffc3
CHKIN = $ffc6
CHKOUT = $ffc9
CHRIN = $ffcf
CHROUT = $ffd2
LOAD = $ffd5
SAVE = $ffd8
WRITEFILENO = $f

CURSOR_COLOR = $286

K_F1 = $85
K_F3 = $86
K_BACKSPACE = $14
K_RETURN = $d
K_CLRSCR = $93
K_SPACE = ' '
K_REVERSE = $c7
K_DOWN = $11
K_RIGHT = $1d
K_UP = $91
K_LEFT = $9d

C_YELLOW = 7

; -------- program start

*= $801 ; start at c64 basic start

!byte $b, $08, $EF, $00, $9E, $32, $30, $36,$31, $00, $00, $00 ; basic header

!ct pet

BORDER_COLOR = 0
SCREEN_COLOR = 0
	
	; set up restore key
	sei
	lda	#<restore_handler
	sta $318
	lda	#>restore_handler
	sta $319
	cli

	; clrscr
	lda #K_CLRSCR
	jsr PUTCHR

	lda	#%00010110 ; lowercase
	sta	$d018

	lda	#BORDER_COLOR
	sta	$d020
	lda	#SCREEN_COLOR
	sta	$d021

	lda	_START
	ora	_START + 1
	bne	reset
	; first time ever app is started...
	jsr	load_base

reset_print_ok
	lda	#<print_ok
	sta	_START
	lda	#>print_ok
	sta	_START + 1

reset
	lda	#BORDER_COLOR
	sta	$d020
	lda	#SCREEN_COLOR
	sta	$d021
	lda	#C_YELLOW
	sta	CURSOR_COLOR

	jsr	clrcol

	lda #0
	sta	_BLINK
	sta CURSOR_BLINK
	lda	#1
	sta	_LINEBUF
	lda	#$40 ; no key repeat
	sta	$28a

	lda	#<_START
	sta IP
	lda #>_START
	sta IP + 1

	ldx	#STACK_START

	jmp	NEXT_IMPL

print_ok
	lda	#'o'
	jsr	PUTCHR
	lda	#'k'
	jsr	PUTCHR
	lda	#$d
	jsr	PUTCHR
	jmp	NEXT_IMPL

restore_handler
	cli
    jmp reset_print_ok

clrcol
	lda	#C_YELLOW
	ldx	#0
-	sta $d800, x
	sta $d900, x
	sta $da00, x
	sta $db00, x
	dex
	bne	-
	rts

; ----------- macros

!macro NEXT {
	jmp	NEXT_IMPL
}

!macro VAR_CODE .word {
	dex
	dex
	lda	#<.word
	sta	0, x
	lda	#>.word
	sta	1, x
	+NEXT
}

; ---------- words

!set LINK = 0

__DOCOL
	lda	IP
	sta	TMP
	lda	IP + 1
	sta	TMP + 1

	pla
	sta	IP
	pla
	sta	IP + 1

	; adjust for weird return address after jsr...
	inc	IP
	bne +
	inc	IP + 1
+

	; push old IP to return stack
	lda	TMP
	pha
	lda	TMP + 1
	pha

	; fall through...

NEXT_IMPL

	; (IP) -> W
	ldy	#1
	lda	(IP), y
	sta	++ + 2
	dey
	lda	(IP), y
	sta	++ + 1

	; IP += 2
	lda	IP
	clc
	adc	#2
	sta	IP
	bcc +
	inc	IP + 1
+

++
	jmp	0

; START - points to the code of the startup word.
	!word	LINK
	!set	LINK = * - 2
	!byte 5
	!text	"start"
	+VAR_CODE	_START
_START
	!word	0
	!word	QUIT

; DROP
	!word	LINK
	!set	LINK = * - 2
	!byte	4
	!text	"drop"
DROP
	inx
	inx
	+NEXT

; SWAP
	!word	LINK
	!set	LINK = * - 2
	!byte	4
	!text	"swap"
SWAP
	ldy	1, x
	lda	3, x
	sta 1, x
	sty	3, x

	ldy	0, x
	lda	2, x
	sta 0, x
	sty	2, x
	+NEXT

; DUP
	!word	LINK
	!set	LINK = * - 2
	!byte	3
	!text	"dup"
DUP
	dex
	dex
	lda	3, x
	sta	1, x
	lda	2, x
	sta	0, x
	+NEXT

_DUP
	dex
	dex
	lda	3, x
	sta	1, x
	lda	2, x
	sta	0, x
	rts

; OVER
	!word	LINK
	!set	LINK = * - 2
	!byte	4
	!text	"over"
OVER
	dex
	dex

	lda	5, x
	sta	1, x
	lda	4, x
	sta	0, x

	+NEXT

; 1+
	!word	LINK
	!set	LINK = * - 2
	!byte	2
	!text	"1+"
INCR
	inc	0, x
	bne	+
	inc	1, x
+
	+NEXT

; 1-
	!word	LINK
	!set	LINK = * - 2
	!byte	2
	!text	"1-"
DECR
	lda	0, x
	bne	+
	dec	1, x
+
	dec	0, x
	+NEXT

; +
	!word	LINK
	!set	LINK = * - 2
	!byte	1
	!text	"+"
ADD
	jsr	_ADD
	+NEXT

_ADD
	lda	0, x
	clc
	adc 2, x
	sta	2, x

	lda	1, x
	adc 3, x
	sta 3, x

	inx
	inx

	rts

; -
	!word	LINK
	!set	LINK = * - 2
	!byte	1
	!text	"-"
SUB
	lda	2, x
	sec
	sbc 0, x
	sta	2, x

	lda 3, x
	sbc 1, x
	sta 3, x

	inx
	inx

	+NEXT

product = TMP

; * - this calculates a 32 bit result, actually. useful? wasteful?
	!word	LINK
	!set	LINK = * - 2
	!byte	1
	!text	"*"
MUL
	jsr	_MUL
    inx
    inx
	lda	product
	sta	0, x
	lda	product + 1
	sta	1, x
	+NEXT

; * - this calculates a 32 bit result, actually. useful? wasteful?
	!word	LINK
	!set	LINK = * - 2
	!byte	2
	!text	"d*"
DMUL
	jsr	_MUL
	lda	product
	sta	0, x
	lda	product + 1
	sta	1, x
	lda	product + 2
	sta	2, x
	lda	product + 3
	sta	3, x
	+NEXT

; wastes TMP, TMP2, y
_MUL
	lda #$00
	sta product+2 ; clear upper bits of product
	sta product+3 
	ldy #$10 ; set binary count to 16 
.shift_r
	lsr 3, x ; multiplier+1 ; divide multiplier by 2 
	ror 2, x ; multiplier
	bcc rotate_r 
	lda product+2 ; get upper half of product and add multiplicand
	clc
	adc 0, x ; multiplicand
	sta product+2
	lda product+3 
	adc 1, x ; multiplicand+1
rotate_r 
	ror ; rotate partial product 
	sta product+3 
	ror product+2
	ror product+1 
	ror product 
	dey
	bne .shift_r 

	rts

; /MOD
	!word	LINK
	!set	LINK = * - 2
	!byte	4
	!text	"/mod"
DIVMOD
remainder = TMP
	lda #16	        ;repeat for each bit: ...
	sta	TMP2
	lda #0	        ;preset remainder to 0
	sta remainder
	sta remainder+1

.divloop	
	asl 2, x ; dividend	;dividend lb & hb*2, msb -> Carry
	rol 3, x ; dividend+1	
	rol remainder	;remainder lb & hb * 2 + msb from carry
	rol remainder+1
	lda remainder
	sec
	sbc 0, x ; divisor	;substract divisor to see if it fits in
	tay	        ;lb result -> Y, for we may need it later
	lda remainder+1
	sbc 1, x ; divisor+1
	bcc .skip	;if carry=0 then divisor didn't fit in yet

	sta remainder+1	;else save substraction result as new remainder,
	sty remainder	
	inc 2, x ; result	;and INCrement result cause divisor fit in 1 times

.skip	
	dec	TMP2
	bne .divloop	

	lda	remainder
	sta	0, x
	lda	remainder + 1
	sta	1, x
	jmp	SWAP

; =
	!word	LINK
	!set	LINK = * - 2
	!byte	1
	!text	"="
EQU
	lda	1, x
	cmp	3, x
	bne	+
	lda	0, x
	cmp	2, x
	bne	+
	lda	#$ff
	jmp	++
+
	lda	#0
++
	inx
	inx
	sta	1, x
	sta	0, x
	+NEXT

; <
	!word	LINK
	!set	LINK = * - 2
	!byte	1
	!text	"<"
LT
	lda	1, x
	cmp	3, x
	bcc .false
	bne	.true
	; ok, msb are equal...
	lda	0, x
	cmp	2, x
	bcc	.false
	bne	.true
.false
	lda	#0
	jmp	++
.true
	lda	#$ff
++
	inx
	inx
	sta	1, x
	sta	0, x
	+NEXT

; 0=
	!word	LINK
	!set	LINK = * - 2
	!byte	2
	!text	"0="
ZEQU
	lda	1, x
	bne +
	lda	0, x
	bne +
	lda	#$ff
	jmp	++
+
	lda	#0
++
	sta	1, x
	sta	0, x
	+NEXT

; AND
	!word	LINK
	!set	LINK = * - 2
	!byte	3
	!text	"and"
AAND
	lda	1, x
	and 3, x
	sta 3, x

	lda	0, x
	and 2, x
	sta 2, x

	inx
	inx

	+NEXT

; !
	!word	LINK
	!set	LINK = * - 2
	!byte	1
	!text	"!"
STORE
	lda	2, x
	sta (0, x)
	inc	0, x
	bne	+
	inc	1, x
+
	lda	3, x
	sta	(0, x)

	inx
	inx
	inx
	inx
	+NEXT

; @
	!word	LINK
	!set	LINK = * - 2
	!byte	1
	!text	"@"
FETCH
	lda	(0, x)
	tay
	inc	0, x
	bne +
	inc 1, x
+
	lda (0, x)
	sta	1, x
	sty	0, x

	+NEXT

; C!
	!word	LINK
	!set	LINK = * - 2
	!byte	2
	!text	"c!"
STOREBYTE
	lda	2, x
	sta (0, x)

	inx
	inx
	inx
	inx

	+NEXT

; C@
	!word	LINK
	!set	LINK = * - 2
	!byte	2
	!text	"c@"
FETCHBYTE
	lda	(0, x)
	sta 0, x
	ldy #0
	sty	1, x
	+NEXT

; FILL ( val start len -- )
	!word	LINK
	!set	LINK = * - 2
	!byte	4
	!text	"fill"
FILL
	lda	4, x
	sta	.fsrc + 1
	lda	2, x
	sta	.fdst + 1
	lda	3, x
	sta	.fdst + 2
	lda	0, x
	eor	#$ff
	sta	TMP
	lda	1, x
	eor	#$ff
	sta	TMP + 1

	inx
	inx
	inx
	inx
	inx
	inx
-
	inc	TMP
	bne	+
	inc	TMP + 1
	bne	+
	+NEXT
+
.fsrc
	lda	#0 ; overwrite
.fdst
	sta	$ffff ; overwrite

	; advance
	inc	.fdst + 1
	bne	+
	inc	.fdst + 2
+
	bne	-


; CMOVE> ( src dst len -- )
	!word	LINK
	!set	LINK = * - 2
	!byte	6
	!text	"cmove>"
CMOVE_BACK
	lda	4, x
	sta	.bsrc + 1
	lda	5, x
	sta	.bsrc + 2
	lda	2, x
	sta	.bdst + 1
	lda	3, x
	sta	.bdst + 2
	lda	0, x
	eor	#$ff
	sta	TMP
	lda	1, x
	eor	#$ff
	sta	TMP + 1

	inx
	inx
	inx
	inx
	inx
	inx
-
	inc	TMP
	bne	+
	inc	TMP + 1
	bne	+
	+NEXT
+
.bsrc
	lda	$ffff ; overwrite
.bdst
	sta	$ffff ; overwrite

	; back
	dec	.bsrc + 1
	lda	.bsrc + 1
	cmp	#$ff
	bne	+
	dec	.bsrc + 2
+
	dec	.bdst + 1
	lda	.bdst + 1
	cmp	#$ff
	bne	+
	dec	.bdst + 2
+
	bne	-

; CMOVE ( src dst len -- ) forward move
	!word	LINK
	!set	LINK = * - 2
	!byte	5
	!text	"cmove"
CMOVE
	lda	4, x
	sta	.csrc + 1
	lda	5, x
	sta	.csrc + 2
	lda	2, x
	sta	.cdst + 1
	lda	3, x
	sta	.cdst + 2
	lda	0, x
	eor	#$ff
	sta	TMP
	lda	1, x
	eor	#$ff
	sta	TMP + 1

	inx
	inx
	inx
	inx
	inx
	inx
-
	inc	TMP
	bne	+
	inc	TMP + 1
	bne	+
	+NEXT
+
.csrc
	lda	$ffff ; overwrite
.cdst
	sta	$ffff ; overwrite

	; advance
	inc	.csrc + 1
	bne	+
	inc	.csrc + 2
+
	inc	.cdst + 1
	bne	+
	inc	.cdst + 2
+
	bne	-

; ---------- variables

; S0
	!word	LINK
	!set	LINK = * - 2
	!byte 3
	!text	"sp0"
	+VAR_CODE	STACK_START

; STATE - Is the interpreter executing code (0) or compiling a word (non-zero)?
	!word	LINK
	!set	LINK = * - 2
	!byte 5
	!text	"state"
	+VAR_CODE	STATE
STATE
	!word	0

; COMPILE_RAM - points to RAM source code to be compiled.
	!word	LINK
	!set	LINK = * - 2
	!byte 11
	!text	"compile-ram"
	+VAR_CODE	COMPILE_RAM
COMPILE_RAM
	!word	0

; HERE - points to the next free byte of memory. When compiling, compiled words go here.
	!word	LINK
	!set	LINK = * - 2
	!byte 4
	!text	"here"
HERE_CODE
	+VAR_CODE	HERE
HERE
	!word	_LATEST + 2

; NEXT
	!word	LINK
	!set	LINK = * - 2
	!byte 4
	!text	"next"
	+VAR_CODE	NEXT_IMPL

; ------------ i/o

; EMIT
	!word	LINK
	!set	LINK = * - 2
	!byte	4
	!text	"emit"
EMIT
	lda	0, x
	inx
	inx
	jsr	print_char
	+NEXT

print_char
	ldy	#20
	sty CURSOR_TIMER
	ldy #1
	sty CURSOR_STATUS ;Force cursor off
	jsr	PUTCHR
	ldy	_BLINK
	sty	CURSOR_BLINK
	rts

print_hex_nibble
	cmp	#10

	bcc	.dec
	; hex
	clc
	adc	#$41 - 10
	jmp	+

.dec
	eor	#$30

+
	jmp	print_char

print_hex_char
	pha
	lsr
	lsr
	lsr
	lsr
	jsr	print_hex_nibble
	pla
	pha
	and	#$f
	jsr	print_hex_nibble
	pla
	rts

; c.
	!word	LINK
	!set	LINK = * - 2
	!byte	2
	!text	"c."
CDOT
	lda	0, x
	lsr
	lsr
	lsr
	lsr
	jsr	print_hex_nibble
	
	lda	0, x
	and	#$f
	jsr	print_hex_nibble

	inx
	inx

	+NEXT

; . - display number on screen
	!word	LINK
	!set	LINK = * - 2
	!byte	1
	!text	"."
DOT
	jsr	_DOT
	+NEXT
_DOT
	lda	1, x
	lsr
	lsr
	lsr
	lsr
	jsr print_hex_nibble

	lda	1, x
	and	#$f
	jsr	print_hex_nibble

	lda	0, x
	lsr
	lsr
	lsr
	lsr
	jsr	print_hex_nibble
	
	lda	0, x
	and	#$f
	jsr	print_hex_nibble

	lda	#K_SPACE
	jsr	print_char

	inx
	inx

	rts

TIB
	!fill 33

tmp_x
	!byte	0

; input key in a
handle_input_char

	; put char in TIB
.dst
	sta $f00d
	inc	.dst + 1
	bne	+
	inc	.dst + 2
+
	rts

KEY_BUF_SIZE = 80
KEY_BUF
	!fill KEY_BUF_SIZE

KEY_BUF_READ_POS
	!byte 0
KEY_BUF_WRITE_POS
	!byte 0

write_key
	ldy	#<KEY_BUF
	sty	TMP
	ldy	#>KEY_BUF 
	sty	TMP + 1

	ldy	KEY_BUF_WRITE_POS
	sta	(TMP), y
	inc	KEY_BUF_WRITE_POS
	rts

; KEY... read a key from disk (if open) or keyboard.
	!word	LINK
	!set	LINK = * - 2
	!byte	3
	!text	"key"
KEY
	jsr	_KEY
	+NEXT

.unbuffered_key
	stx	tmp_x
	jsr	PULL_KEY
    ldx tmp_x
	ora	#0
	beq	_KEY
	dex
	dex
	sta	0, x
	lda	#0
	sta	1, x
	rts

_KEY
    lda COMPILE_FILENO
    ora COMPILE_RAM + 1
	bne	.unbuffered_key
	lda	_LINEBUF
	beq	.unbuffered_key
	lda	KEY_BUF_WRITE_POS
	beq	.fill_key_buf
	cmp	KEY_BUF_READ_POS
	bne	.get_from_key_buf

.fill_key_buf
	; start filling key buf... TODO: add bounds check for buffer overwrite.
	lda	#0
	sta	KEY_BUF_READ_POS
	sta	KEY_BUF_WRITE_POS

-
	stx	tmp_x
	jsr PULL_KEY
	ldx	tmp_x
	ora	#0
	beq	-
	cmp	#K_RETURN
	beq	.return

	; should key be ignored?
	cmp	#K_LEFT
	beq	-
	cmp	#K_RIGHT
	beq	-
	cmp	#K_UP
	beq	-
	cmp	#K_DOWN
	beq	-

	; shift + space => space
	cmp	#$a0
	bne +
	lda	#K_SPACE	
+

	cmp	#K_BACKSPACE
	bne	+
	tay
	lda	KEY_BUF_WRITE_POS
	beq	-
	dec	KEY_BUF_WRITE_POS
	tya
	jsr	print_char
	jmp	-
+
	jsr	print_char
	
	jsr	write_key
	jmp	-

.return	;done
	lda	#K_SPACE
	jsr	print_char
	lda	#K_RETURN
	jsr	print_char

	jsr	write_key

	jmp	_KEY

.get_from_key_buf
	ldy	#<KEY_BUF
	sty	TMP
	ldy	#>KEY_BUF 
	sty	TMP + 1

	ldy	KEY_BUF_READ_POS
	lda	(TMP), y
	inc	KEY_BUF_READ_POS

	dex
	dex
	sta	0, x
	lda	#0
	sta	1, x
	rts

; Reads a key, sources are prioritized as follows:
;  1. Streaming file from disk (COMPILE_FILENO)
;  2. Compile RAM area (COMPILE_RAM)
;  3. Console input
PULL_KEY ; wastes x!!!
	lda	COMPILE_FILENO
	bne	.get_char_from_disk

    ; compiling from RAM?
	lda	COMPILE_RAM + 1
	beq	+++
	; yes - get char from RAM area
    inc $d020
	sta	TMP + 1
	lda	COMPILE_RAM
	sta	TMP
	ldy #0
    dec $d020
	lda	(TMP), y
	beq	++
	inc	COMPILE_RAM
	bne	+
	inc	COMPILE_RAM + 1
+
	rts
++
    ; Stop compiling from RAM.
	sta	COMPILE_RAM + 1
    sta _BLINK
    sta CURSOR_BLINK
+++
    ; Read from console.
	jmp	GETCHR

.get_char_from_disk
    inc $d020
	jsr	READST
	bne .eof
    dec $d020
	jmp	CHRIN

.eof
	lda	COMPILE_FILENO
	jsr	CLOSE
    dec $d020

	dec	COMPILE_FILENO
	bne +
	lda	_BLINK
	sta	CURSOR_BLINK
+
	lda	COMPILE_FILENO
	jsr	CHKIN
    jmp PULL_KEY  ; Try again.
	
; WORD ( -- strptr )
	!word	LINK
	!set	LINK = * - 2
	!byte	4
	!text	"word"
WORD
	jsr _WORD
	+NEXT

_WORD
	; prepare text input
	lda	#<(TIB + 1) 
	sta	.dst + 1
	lda	#>(TIB + 1)
	sta	.dst + 2
	lda	#0
	sta	.entered_chars_count
	
-
	jsr	_KEY
	lda	0, x
	inx
	inx

	cmp #K_RETURN
	beq .whitespace
	cmp #K_SPACE
	beq .whitespace

	cmp	#K_BACKSPACE
	bne	++
	dec	.entered_chars_count
	lda	.dst+1
	bne	+
	dec	.dst+2
+
	dec	.dst+1
	jmp	-
++

	inc	.entered_chars_count

	jsr	handle_input_char

	jmp	-

.whitespace
	; return text string
	lda	.entered_chars_count
	beq - ; whoops, nothing entered, try again...
	sta TIB 

	dex
	dex

	lda	#<TIB
	sta	0, x
	lda	#>TIB
	sta	1, x

	rts

.entered_chars_count
	!byte	0

; FIND
	!word	LINK
	!set	LINK = * - 2
	!byte	4
	!text	"find"
FIND
	jsr	_FIND
	+NEXT
_FIND
    txa
    pha

	lda	_LATEST
	sta	TMP
	lda	_LATEST + 1
	sta	TMP + 1
	; TMP now contains pointer to the most recently defined dictionary word.

	lda	1, x
	sta	TMP2 + 1
	lda	0, x
	sta	TMP2 ; TMP2 contains pointer to find string

	ldy	#0
	lda	(TMP2), y ; get length of find string
    ; store findlen
	sta	.findlen + 1
	sta	.findlen2 + 1

    ; TMP2 -= 2. This prepares for .string_compare.
    lda TMP2
    bne +
    dec TMP2 + 1
+   dec TMP2
    lda TMP2
    bne +
    dec TMP2 + 1
+   dec TMP2

.examine_word
	ldy	#2
	lda	(TMP), y ; get string length of dictionary word
	and	#STRLEN_MASK | F_HIDDEN ; include hidden flag... so we don't find the hidden words.
.findlen
	cmp	#0
	beq	.string_compare

.word_not_equal
	; no match, advance the linked list.
	ldy	#0
	lda	(TMP), y
    tax
	iny
	lda	(TMP), y
	sta	TMP + 1
	stx	TMP
	; TMP now contains new dictionary word.

    ; Is word null? If not, examine it.
    bne .examine_word
	lda	TMP + 1
    bne .examine_word

	; It is null - give up.
    pla
    tax
    lda #0
	sta	0, x
	sta	1, x
	rts
	
.string_compare
	; equal strlen, now compare strings...
.findlen2
    lda #0
    sta .strlen
-   iny
	lda	(TMP), y ; get char of dictionary string
	cmp	(TMP2), y ; compare with find string
	bne	.word_not_equal
	dec	.strlen
	beq	.word_is_equal
	jmp	-

.strlen !byte 0
	
.word_is_equal
	; return address to dictionary word
    pla
    tax
	lda	TMP
	sta	0, x
	lda	TMP + 1
	sta	1, x
	rts ; a should be non-zero now

; >CFA
	!word	LINK
	!set	LINK = * - 2
	!byte	4
	!text	">cfa"
TCFA
	jsr _TCFA
	+NEXT
_TCFA
	lda	1, x
	sta	TMP + 1
	lda	0, x
	sta TMP
	; TMP contains pointer to word
	ldy	#2
	lda	(TMP), y ; a contains string length + mask
	and	#STRLEN_MASK
	clc
	adc	#3 ; offset for link + string length
	sta	.addend + 1
	lda	0, x
.addend
	adc	#0
	sta	0, x
	bcc	+
	inc	1, x
+
	rts

; EXEC
	!word	LINK
	!set	LINK = * - 2
	!byte	4
	!text	"exec"
EXEC
	lda	0, x
	sta TMP
	lda	1, x
	sta	TMP + 1
	inx
	inx
	jmp	(TMP)

; Z set = success, clear = failed
_NUMBER ; only hex
	lda	1, x	
	sta	TMP3 + 1
	lda	0, x	
	sta	TMP3
	; TMP3 now contains a string ptr...
	ldy	#0
	lda	(TMP3), y
	sta	.chars_to_process
	; clear stack...
	lda	#0
	sta	0, x
	sta	1, x

.number_handler
	jsr	handle_input_digit_hex

	bne	.not_digit

	dec	.chars_to_process
	bne	.number_handler

.not_digit
	rts

.chars_to_process
!byte 0

handle_input_digit_hex
	; multiply stack top by 16
	dex
	dex

	lda	#16
	sta	0, x
	lda	#0
	sta	1, x

	tya
	pha
	jsr	_MUL
    inx
    inx
	lda	product
	sta	0, x
	lda	product + 1
	sta	1, x
	pla
	tay

	; add *(++TMP3) to stack top
	iny
	lda	(TMP3), y
	clc
	adc	#-$30 ; petscii 0-9 -> 0-9

	sec ; within 0-9?
	cmp	#10
	bcc	.ok

	clc
	adc	#-$7 ; a-f...

	sec ; within a-f?
	cmp	#16
	bcs	.not_a_digit
	sec
	cmp	#10
	bcc	.not_a_digit

.ok
	dex
	dex

	sta	0, x
	lda	#0
	sta	1, x

	jsr	_ADD

	lda	#0
	rts

.not_a_digit
	lda	#1
	rts

; INTERPRET
	!word	LINK
	!set	LINK = * - 2
	!byte	9
	!text	"interpret"
INTERPRET
    ; Checks for stack underflow.
    txa
    cmp #STACK_START+1
    bpl .on_stack_underflow

	jsr	_WORD ; push string to stack

	jsr	_DUP ; dup string
	jsr	_FIND ; replace string with dictionary ptr
	bne	.found_word

	; didn't find word...
	; assume it's a literal number.

	inx ; drop null dictionary ptr
	inx
	jsr _NUMBER
	bne	.on_word_not_found_error

	; yep, it's a number...
	lda	STATE ; are we compiling?
	beq	.leave_number_on_stack ; no, leave number on stack
	; yes. compile literal.
	dex
	dex
	lda	#<LIT
	sta	0, x
	lda	#>LIT
	sta	1, x
	jsr	_COMMA ; writes LIT
	jsr	_COMMA ; writes number

.leave_number_on_stack
	+NEXT

.on_stack_underflow
	lda	#$12 ; reverse on
	jsr	print_char
    lda #'e'
	jsr	print_char
    lda #'r'
	jsr	print_char
	jsr	print_char
    jmp .stop_error_print

.found_word
	; OK, we found a word...

	; is it immediate?
	lda	0, x
	sta	TMP
	lda	1, x
	sta	TMP + 1
	ldy	#2 ; skip link ptr, look at flags
	lda	(TMP), y
	and	#F_IMMED
	bne	.execute_word ; yes... execute it.

	lda	STATE ; are we compiling?
	beq	.execute_word ; no, execute it.

	; OK, this word should be compiled...
	jsr	_TCFA
	jsr	_COMMA
	inx ; drop string
	inx
	+NEXT

.execute_word
	jsr	_TCFA

	; copy CFA to TMP
	lda	0, x
	sta	TMP
	lda	1, x
	sta	TMP + 1
	; drop CFA + string
	inx
	inx
	inx
	inx
	jmp	(TMP)

.on_word_not_found_error
	lda	#$12 ; reverse on
	jsr	print_char

	ldy	TIB
	lda	#<TIB
	sta	TMP
	lda	#>TIB
	sta	TMP + 1

-
	inc	TMP
	bne	+
	inc	TMP + 1
+

	tya
	pha

	ldy	#0
	lda	(TMP), y
	jsr	print_char

	pla
	tay

	dey
	bne -

	lda	#'?'
	jsr	print_char

.stop_error_print
	lda	#$92 ; reverse off
	jsr	print_char

	lda	#' '
	jsr	print_char

    ; Resets some sensitive things, as part of error handling.
    ldx     #0
    stx     STATE
    stx     KEY_BUF_READ_POS
    stx     KEY_BUF_WRITE_POS
    stx     COMPILE_FILENO
    stx     COMPILE_RAM + 1
    jsr     CHKIN
    ldx     #STACK_START ; wipe stack :(
	+NEXT

; TICK
	!word	LINK
	!set	LINK = * - 2
	!byte	1
	!text	"'"
TICK
    ; tick and lit do the same thing, but tick is used for
    ; words, lit for numbers.
	jmp	LIT

; LIT
	!word	LINK
	!set	LINK = * - 2
	!byte	3
	!text	"lit"
LIT
	; grow stack
	dex
	dex

	; copy literal to stack
	ldy	#0
	lda	(IP), y
	sta	0, x

	iny
	lda	(IP), y
	sta	1, x

	; IP += 2
	clc
	lda	IP
	adc #2	
	bcc	+
	inc	IP + 1
+
	sta	IP

	+NEXT

; QUIT
	!word	LINK
	!set	LINK = * - 2
	!byte	4
	!text	"quit"
QUIT
	jsr	__DOCOL
	!word	INTERPRET
	!word	BRANCH
	!word	-4

; EXIT
	!word	LINK
	!set	LINK = * - 2
	!byte	4
	!text	"exit"
EXIT
	pla
	sta	IP + 1
	pla
	sta	IP
	+NEXT


; blink (0 = enable, 1 = disable)
	!word	LINK
	!set	LINK = * - 2
	!byte	5
	!text	"blink"
BLINK
	lda	0, x
    eor #1
	sta	_BLINK
	sta	CURSOR_BLINK
	inx
	inx
	+NEXT
_BLINK
	!byte	0

; CREATE ( name -- )
	!word	LINK
	!set	LINK = * - 2
	!byte	6
	!text	"create"
CREATE
	jsr	_WORD

	; store link in header. TMP = dst
	lda	HERE
	sta	TMP
	lda	HERE + 1
	sta	TMP + 1

	ldy	#0
	lda	_LATEST
	sta	(TMP), y

	inc	TMP
	bne	+
	inc	TMP + 1
+
	lda	_LATEST + 1
	sta	(TMP), y

	inc	TMP
	bne	+
	inc	TMP + 1
+

	; store length byte in header. TMP2 = src
	lda	0, x
	sta	TMP2
	lda	1, x
	sta	TMP2 + 1
	lda	(TMP2), y
	sta	(TMP), y	

	; save stack ptr to use x as loop counter
	txa
	pha

	; copy string
	lda	(TMP2), y
	tax
-
	iny
	lda	(TMP2), y
	sta	(TMP), y

	dex
	bne	-

	; update _LATEST
	lda	HERE
	sta	_LATEST
	lda	HERE + 1
	sta	_LATEST + 1
	
	; update HERE
	iny
	tya
	clc
	adc	TMP
	sta	HERE
	bcc	+
	inc	TMP + 1
+
	lda	TMP + 1
	sta	HERE + 1

	; restore stack ptr
	pla
	tax

	inx
	inx

	+NEXT

; CCOMMA - write char
	!word	LINK
	!set	LINK = * - 2
	!byte	2
	!text	"c,"
CCOMMA
	lda	HERE
	sta	TMP
	lda	HERE + 1
	sta	TMP + 1

	ldy	#0
	lda	0, x
	sta	(TMP), y

	; update HERE
	inc	HERE
	bne	+
	inc HERE + 1
+
	inx
	inx
	+NEXT

; COMMA - write word
	!word	LINK
	!set	LINK = * - 2
	!byte	1
	!text	","
COMMA
	jsr	_COMMA
	+NEXT
_COMMA
	lda	HERE
	sta	TMP
	lda	HERE + 1
	sta	TMP + 1

	ldy	#0
	lda	0, x
	sta	(TMP), y
	iny
	lda	1, x
	sta	(TMP), y

	; update HERE
	lda	HERE
	clc
	adc	#2
	sta	HERE
	bcc	+
	inc HERE + 1
+
	inx
	inx
	rts

; LBRAC
	!word	LINK
	!set	LINK = * - 2
	!byte	1 | F_IMMED
	!text	"["
LBRAC
	lda	#0
	sta	STATE
	+NEXT

; RBRAC
	!word	LINK
	!set	LINK = * - 2
	!byte	1
	!text	"]"
RBRAC
	lda	#1
	sta	STATE
	+NEXT

; SEMICOLON
	!word	LINK
	!set	LINK = * - 2
	!byte	1 | F_IMMED
	!text	";"
SEMICOLON
	jsr	__DOCOL
	!word LIT, EXIT, COMMA ; append EXIT (so that the word will return).
	!word LATEST, FETCH, HIDDEN ; unhide the word.
	!word LBRAC ; go back to IMMEDIATE mode.
	!word EXIT

; IMMEDIATE. Flip the immediate flag of the LATEST word.
	!word	LINK
	!set	LINK = * - 2
	!byte	5 | F_IMMED
	!text	"immed"
IMMED
	lda	_LATEST
	sta	TMP
	lda	_LATEST + 1
	sta	TMP + 1
	ldy	#2
	lda	(TMP), y
	eor	#F_IMMED
	sta	(TMP), y
	+NEXT

; BRANCH

	!word	LINK
	!set	LINK = * - 2
	!byte	6
	!text	"branch"
BRANCH
	; IP is now pointing to the offset by which IP should be modified...
	ldy	#0
	lda	(IP), y
	clc
	adc IP
	sta	TMP
	iny
	lda	(IP), y
	adc	IP + 1
	sta	IP + 1

	lda	TMP
	sta	IP

	+NEXT

; 0BRANCH
	!word	LINK
	!set	LINK = * - 2
	!byte	7
	!text	"0branch"
ZBRANCH
	lda	1, x
	ora	0, x
	bne .dont_branch
	inx
	inx
	jmp BRANCH

.dont_branch
	inx
	inx
	; skip offset
	lda	IP
	clc
	adc	#2
	sta	IP
	bcc	+
	inc	IP + 1
+
	+NEXT

; COLON
	!word	LINK
	!set	LINK = * - 2
	!byte	1
	!text	":"
COLON
	jsr	__DOCOL
	!word CREATE ; CREATE the dictionary entry / header
	!word LIT, OP_JSR, CCOMMA ; insert jmp
	!word LIT, __DOCOL, COMMA ; append __DOCOL (the codeword)
	!word LATEST, FETCH, HIDDEN ; hide word
	!word RBRAC ; enter compile mode
	!word EXIT

; HIDDEN
	!word	LINK
	!set	LINK = * - 2
	!byte	6
	!text	"hidden"
HIDDEN
	lda	0, x
	sta	TMP
	lda	1, x
	sta TMP + 1

	ldy	#2 ; skip link, point to flags
	lda	(TMP), y
	eor	#F_HIDDEN ; toggle hidden flag
	sta	(TMP), y
	inx
	inx
	+NEXT

; DSP@
	!word	LINK
	!set	LINK = * - 2
	!byte	3
	!text	"sp@"
SPFETCH
	txa
	dex
	dex
	sta	0, x
	lda	#0
	sta	1, x
	+NEXT

; LITSTRING
	!word	LINK
	!set	LINK = * - 2
	!byte	9
	!text	"litstring"
LITSTRING ; ( -- addr len )
	; grow stack
	dex
	dex
    dex
    dex

	; copy string addr to stack
	ldy	#0

	lda	IP
	sta	TMP
    sta 2, x ; addr lsb

	iny
	lda	IP + 1
	sta	TMP + 1
    sta 3, x ; addr msb

    inc 2, x ; skip len
    bne +
    inc 3, x
+

	; TMP now points to string length
	dey ; y = 0
    sty 1, x ; len msb=0
	lda	(TMP), y
    sta 0, x ; len lsb

	tay ; y = *TMP
	iny ; add one for length byte
	sty	.lstrlen + 1

	; skip string
	lda	IP
	clc
.lstrlen
	adc #0 ; overwritten
	sta	IP
	bcc	+
	inc	IP + 1
+
	+NEXT

; -----------

; LINEBUF line buffering. 0 = off, 1 = on
	!word	LINK
	!set	LINK = * - 2
	!byte 7
	!text	"linebuf"
LINEBUF
	+VAR_CODE	_LINEBUF
_LINEBUF
	!word	1

; COMPILE_FILENO - active file stream to compile from.
	!word	LINK
	!set	LINK = * - 2
	!byte 6
	!text	"compile-fileno"
	+VAR_CODE	COMPILE_FILENO
COMPILE_FILENO
	!word	0

; DOCOL
	!word	LINK
	!set	LINK = * - 2
	!byte 5
	!text	"docol"
DOCOL
	+VAR_CODE	__DOCOL

; CLOSEW
	!word	LINK
	!set	LINK = * - 2
	!byte 6
	!text	"closew"
CLOSEW
	stx	tmp_x
	lda	#WRITEFILENO
	jsr	CLOSE 
	ldx	#WRITEFILENO
	jsr	CHKOUT
	jsr	_errorchread
	ldx tmp_x
	+NEXT

_errorchread
        LDA #$00      ; no filename
        LDX #$00
        LDY #$00
        JSR SETNAM
        LDA #$0F      ; file number 15
        LDX $BA       ; last used device number
        BNE +
        LDX #$08      ; default to device 8
+	    LDY #$0F      ; secondary address 15 (error channel)
        JSR SETLFS

        JSR OPEN
        BCS .error    ; if carry set, the file could not be opened

        LDX #$0F      ; filenumber 15
        JSR CHKIN     ; file 15 now used as input

        LDY #$00
.loop   JSR READST    ; read status byte
        BNE geof      ; either EOF or read error
        JSR CHRIN     ; get a byte from file
        JSR CHROUT    ; print byte to screen
        JMP .loop     ; next byte

geof
.glose
        LDA #$0F      ; filenumber 15
        JSR CLOSE

        LDX #$00      ; filenumber 0 = keyboard
        JSR CHKIN     ; keyboard now input device again
        RTS
.error
        ; Akkumulator contains BASIC error code

        ; most likely error:
        ; A = $05 (DEVICE NOT PRESENT)

        ; ... error handling for open errors ...
        JMP .glose    ; even if OPEN failed, the file has to be closed


; LOADB ( filenameptr filenamelen dst -- status ) load binary file
;  - s" base" 7000 loadb #load file to 7000
;  - end of loaded file is available in $ae/$af afterwards
	!word	LINK
	!set	LINK = * - 2
	!byte 5
	!text	"loadb"
LOADB
	txa
	pha

	lda 1, x		; >destination
	sta load_binary_laddr_hi
	lda 0, x		; <destination
	sta load_binary_laddr_lo

	lda 2, x		; a filename length
	pha
	ldy 5, x 		; y >basename 
	lda 4, x		; x <basename 
	tax
	pla
	jsr	load_binary
	
	pla
	tax

	inx
	inx
	inx
	inx
	lda	load_binary_status
	sta	1, x
	sta	0, x
	beq	+
	txa
	pha
	jsr	_errorchread
	pla
	tax
+
	+NEXT

load_binary_status
	!byte	0

;load_binary_base
;	lda	#basename_end - basename
;	ldx	#<basename
;	ldy	#>basename
;	; fall through...

load_binary
	jsr .disk_io_setnamsetlfs

load_binary_laddr_lo = *+1
	ldx #$ff	;<load_address
load_binary_laddr_hi = *+1
	ldy #$ff	;>load_address
	lda #0		;0 = load to memory (no verify)
	sta	load_binary_status
	jsr LOAD
	bcs .disk_io_error
	ldx #$00      ; filenumber 0 = keyboard
	jmp CHKIN     ; call CHKIN (keyboard now input device again)

.disk_io_setnamsetlfs ;reused by both loadb and saveb
	jsr SETNAM
	lda $ba		;last used device number
	and #3		;Make 0-3 possible numbers
	ora #8		;Transform to 8-B
	tax
	lda #1
	ldy #0		;if load: 0 = load to new address, if save: 0 = dunno, but okay... 
	jmp SETLFS	;End with JMP instead of jsr/rts to save a jsr/rts pair...


.disk_io_error
	; Accumulator contains BASIC error code
	
	;... error handling ...
	ldx #$00      ; filenumber 0 = keyboard
	jsr CHKIN     ; call CHKIN (keyboard now input device again)
	lda	#1
	sta	load_binary_status
	rts

; SAVEB (save binary file)
;  - 7000 71ae s" base" saveb #save file from 7000 to 71ae (= the byte AFTER the last byte in the file)
	!word	LINK
	!set	LINK = * - 2
	!byte 5
	!text	"saveb"
SAVEB
	stx tmp_x

	lda	$ae
	pha
	lda	$af
	pha

	lda 6, x		; range begin lo
	sta $c1
	lda 7, x		; range begin hi
	sta $c2
	
	lda 4, x		; range end lo
	sta save_binary_srange_end_lo
	lda 5, x		; range end hi
	sta save_binary_srange_end_hi

	lda 0, x		; a filename length
	pha
	ldy 3, x 		; y basename hi
	lda 2, x		; x basename lo
	tax
	pla

	jsr .disk_io_setnamsetlfs
	
	;This should point to the byte AFTER the last byte in the file.
save_binary_srange_end_lo = *+1
	ldx #$ff	;load_address lo
save_binary_srange_end_hi = *+1
	ldy #$ff	;load_address hi
	lda #$c1	;tell routine that start address is located in $c1/$c2
	jsr SAVE
	bcs .disk_io_error

	pla
	sta	$af
	pla
	sta	$ae

	ldx tmp_x
	inx
	inx
	inx
	inx
	inx
	inx
	inx
	inx
	+NEXT


; OPENW ( strptr strlen ) open file for writing
	!word	LINK
	!set	LINK = * - 2
	!byte 5
	!text	"openw"
OPENW
	stx	tmp_x

	lda	0, x
	ldy	3, x
	pha
	lda	2, x
	tax
	pla
	
	jsr	SETNAM
	lda	#WRITEFILENO ; file number
	ldx	#8 ; default to device 8
	tay ; secondary address
	jsr	SETLFS
	jsr	OPEN
	bcs	.could_not_open

	ldx	#WRITEFILENO ; file number
	jsr	CHKOUT

	ldx	tmp_x
	inx
	inx
	inx
	inx
	+NEXT

; LOAD_AND_COMPILE (load and compile source file)
	!word	LINK
	!set	LINK = * - 2
	!byte 4
	!text	"load"
LOAD_AND_COMPILE
    lda #1
    sta CURSOR_BLINK

	txa
	pha

	lda	0, x
	ldy	3, x
	pha
	lda	2, x
	tax
	pla

    ; open file
	; a = filename length
	; y = basename hi
	; x = basename lo
	jsr	SETNAM
	inc	COMPILE_FILENO
	lda	COMPILE_FILENO ; file number
	ldx	#8 ; default to device 8
	tay
	iny ; secondary address
	jsr	SETLFS
	jsr	OPEN
	bcs	.could_not_open

	ldx	COMPILE_FILENO ; file number
	jsr	CHKIN

	pla
	tax
    inx
    inx
    inx
    inx
	+NEXT

.could_not_open
	inc	$d020
	jmp	.could_not_open

load_base
    ; loads base.fs to $5000
    lda #0
    sta load_binary_laddr_lo
    sta COMPILE_RAM
    lda #$50
    sta load_binary_laddr_hi
    sta COMPILE_RAM + 1
	ldx	#<basename
	ldy	#>basename
	lda	#basename_end - basename
    jsr load_binary
    ; Null terminates source code.
    lda $ae    
    sta + + 1
    lda $af
    sta + + 2
    lda #0
+   sta $1234
    rts

basename
!text	"base"
basename_end

; LATEST - points to the most recently defined dictionary word.
	!word	LINK
	!set	LINK = * - 2
	!byte 6
	!text	"latest"
LATEST
	+VAR_CODE	_LATEST
_LATEST
	!word	LINK

; PUT NO CONTENT AFTER LATEST!!!! It will be overwritten!!!!
