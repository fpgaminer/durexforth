;The MIT License
;
;Copyright (c) 2008 Johan Kotlinski
;
;Permission is hereby granted, free of charge, to any person obtaining a copy
;of this software and associated documentation files (the "Software"), to deal
;in the Software without restriction, including without limitation the rights
;to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
;copies of the Software, and to permit persons to whom the Software is
;furnished to do so, subject to the following conditions:
;
;The above copyright notice and this permission notice shall be included in
;;all copies or substantial portions of the Software.
;
;THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
;IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
;FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
;AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
;LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
;OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
;THE SOFTWARE.


; ACME assembler

!cpu 6510
!svl "durexforth.lbl"
!to "durexforth.prg", cbm	; set output file and format

F_IMMED = $80
F_HIDDEN = $40
STRLEN_MASK = $3f

TMP = $30
TMP2 = $32

OP_JSR = $20
OP_RTS = $60
OP_LDA_I = $a9
OP_STA_AX = $9d
OP_INX = $e8

PSTACK_X_OFFSET = 0
PSTACK = $2408
EDIT_BUFFER = $2000 ; - $23ff

EDIT_WORD = 0

; X = PSP
; SP = RSP

; kernal defs

GETCHR = $ffe4 ; get char from kbd
PUTCHR = $ffd2 ; put char
SETGETCURSOR = $fff0

BLINK_COLOR = $286

K_F1 = $85
K_F3 = $86
K_BACKSPACE = $14
K_RETURN = $d
K_CLRSCR = $93
K_SPACE = ' '
K_REVERSE = $c7

C_YELLOW = 7
C_GREEN = 5
C_LT_GREEN = 13
C_BEIGE = 10
C_ORANGE = 8
C_RED = 2
C_MAGENTA = 4
C_BLUE = 14
C_CYAN = 3

; -------- program start

*= $801 ; start at c64 basic start

!byte $b, $08, $EF, $00, $9E, $32, $30, $36,$31, $00, $00, $00 ; basic header

!ct pet

	; screen color = black
	lda	#0
	sta	$d021
	sta	$d020

	; activate cursor
	sta	$cc

	; clrscr
	lda	#K_CLRSCR
	jsr	PUTCHR

	lda	#%00010110 ; lowercase
	sta	$d018

	ldx	#0

	lda	#0
-
	sta	EDIT_BUFFER, x
	sta	EDIT_BUFFER + $100, x
	sta	EDIT_BUFFER + $200, x
	sta	EDIT_BUFFER + $300, x
	
	inx
	bne	-

	jmp	QUIT

; ----------- macros

!macro dbgbrk {
	inc	$d020
-
	jmp	-
}

!macro NEXT {
	rts
}

!macro dex4 {
	txa
	sbx #4 ; equals dex 4 times
}


!macro reset_cursor {
	lda	#0
	sta	$cf
}

!macro PUSH_TO_PRM_STACK .word {
	lda	#<.word
	sta	PSTACK, x
	lda	#>.word
	sta	PSTACK + 1, x
	inx
	inx
}

!macro VAR_CODE .word {
	+PUSH_TO_PRM_STACK .word
	+NEXT
}

in_editor
	!byte	0

; ---------- words

!set LINK = 0

; DROP
	!word	LINK
	!set	LINK = * - 2
	!byte	4
	!text	"drop"
DROP
	dex
	dex
	+NEXT

; SWAP
	!word	LINK
	!set	LINK = * - 2
	!byte	4
	!text	"swap"
SWAP
	ldy	PSTACK - 1, x
	lda	PSTACK - 3, x
	sta PSTACK - 1, x
	tya
	sta	PSTACK - 3, x

	ldy	PSTACK - 2, x
	lda	PSTACK - 4, x
	sta PSTACK - 2, x
	tya
	sta	PSTACK - 4, x
	+NEXT

; DUP
	!word	LINK
	!set	LINK = * - 2
	!byte	3
	!text	"dup"
DUP
	inx
	inx

	lda	PSTACK - 3, x
	sta	PSTACK - 1, x
	lda	PSTACK - 4, x
	sta	PSTACK - 2, x
	+NEXT

; OVER
	!word	LINK
	!set	LINK = * - 2
	!byte	4
	!text	"over"
OVER
	inx
	inx

	lda	PSTACK - 5, x
	sta	PSTACK - 1, x
	lda	PSTACK - 6, x
	sta	PSTACK - 2, x

	+NEXT

; ROT
	!word	LINK
	!set	LINK = * - 2
	!byte	3
	!text	"rot"
ROT
	ldy	PSTACK - 5, x
	lda	PSTACK - 3, x
	sta PSTACK - 5, x
	lda PSTACK - 1, x
	sta PSTACK - 3, x
	tya
	sta PSTACK - 1, x

	ldy	PSTACK - 6, x
	lda	PSTACK - 4, x
	sta PSTACK - 6, x
	lda PSTACK - 2, x
	sta PSTACK - 4, x
	tya
	sta PSTACK - 2, x

	+NEXT

; -ROT
	!word	LINK
	!set	LINK = * - 2
	!byte	4
	!text	"-rot"
NROT
	ldy	PSTACK - 1, x
	lda	PSTACK - 3, x
	sta PSTACK - 1, x
	lda PSTACK - 5, x
	sta PSTACK - 3, x
	tya
	sta PSTACK - 5, x

	ldy	PSTACK - 2, x
	lda	PSTACK - 4, x
	sta PSTACK - 2, x
	lda PSTACK - 6, x
	sta PSTACK - 4, x
	tya
	sta PSTACK - 6, x

	+NEXT

; 2DROP
	!word	LINK
	!set	LINK = * - 2
	!byte	5
	!text	"2drop"
TWODROP
	+dex4

	+NEXT

; 2DUP
	!word	LINK
	!set	LINK = * - 2
	!byte	4
	!text	"2dup"
TWODUP
	inx
	inx
	inx
	inx

	lda	PSTACK - 5, x
	sta	PSTACK - 1, x
	lda	PSTACK - 6, x
	sta	PSTACK - 2, x

	lda	PSTACK - 7, x
	sta	PSTACK - 3, x
	lda	PSTACK - 8, x
	sta	PSTACK - 4, x

	+NEXT

; 2SWAP
	!word	LINK
	!set	LINK = * - 2
	!byte	5
	!text	"2swap"
TWOSWAP

	ldy	PSTACK - 1, x
	lda	PSTACK - 5, x
	sta PSTACK - 1, x
	tya
	sta	PSTACK - 5, x

	ldy	PSTACK - 2, x
	lda	PSTACK - 6, x
	sta PSTACK - 2, x
	tya
	sta	PSTACK - 6, x

	ldy	PSTACK - 3, x
	lda	PSTACK - 7, x
	sta PSTACK - 3, x
	tya
	sta	PSTACK - 7, x

	ldy	PSTACK - 4, x
	lda	PSTACK - 8, x
	sta PSTACK - 4, x
	tya
	sta	PSTACK - 8, x

	+NEXT

; ?DUP
	!word	LINK
	!set	LINK = * - 2
	!byte	4
	!text	"?dup"
QDUP
	lda	PSTACK - 1, x
	ora	PSTACK - 2, x
	beq	+
	inx
	inx
	lda	PSTACK - 3, x
	sta PSTACK - 1, x
	lda	PSTACK - 4, x
	sta PSTACK - 2, x
+
	+NEXT

; 1+
	!word	LINK
	!set	LINK = * - 2
	!byte	2
	!text	"1+"
INCR
	inc	PSTACK - 2, x
	beq	+
	inc	PSTACK - 1, x
+
	+NEXT

; 1-
	!word	LINK
	!set	LINK = * - 2
	!byte	2
	!text	"1-"
DECR
	lda	PSTACK - 2, x
	beq	+
	dec	PSTACK - 1, x
+
	dec	PSTACK - 2, x
	+NEXT

; +
	!word	LINK
	!set	LINK = * - 2
	!byte	1
	!text	"+"
ADD
	lda	PSTACK - 2, x
	clc
	adc PSTACK - 4, x
	sta	PSTACK - 4, x

	lda	PSTACK - 1, x
	adc PSTACK - 3, x
	sta PSTACK - 3, x

	dex
	dex

	+NEXT

; -
	!word	LINK
	!set	LINK = * - 2
	!byte	1
	!text	"-"
SUB
	lda	PSTACK - 4, x
	sec
	sbc PSTACK - 2, x
	sta	PSTACK - 4, x

	lda PSTACK - 3, x
	sbc PSTACK - 1, x
	sta PSTACK - 3, x

	dex
	dex

	+NEXT

; * - this calculates a 32 bit result, actually. useful? wasteful?
	!word	LINK
	!set	LINK = * - 2
	!byte	1
	!text	"*"
MUL
product = TMP

	lda #$00
	sta product+2 ; clear upper bits of product
	sta product+3 
	ldy #$10 ; set binary count to 16 
.shift_r
	lsr PSTACK - 3, x ; multiplier+1 ; divide multiplier by 2 
	ror PSTACK - 4, x ; multiplier
	bcc rotate_r 
	lda product+2 ; get upper half of product and add multiplicand
	clc
	adc PSTACK - 2, x ; multiplicand
	sta product+2
	lda product+3 
	adc PSTACK - 1, x ; multiplicand+1
rotate_r 
	ror ; rotate partial product 
	sta product+3 
	ror product+2
	ror product+1 
	ror product 
	dey
	bne .shift_r 

	dex
	dex

	lda	product
	sta	PSTACK - 2, x
	lda	product + 1
	sta	PSTACK - 1, x

	rts

; /MOD
	!word	LINK
	!set	LINK = * - 2
	!byte	4
	!text	"/mod"
DIVMOD
remainder = TMP
	lda #16	        ;repeat for each bit: ...
	sta	TMP2
	lda #0	        ;preset remainder to 0
	sta remainder
	sta remainder+1

.divloop	
	asl PSTACK - 4, x ; dividend	;dividend lb & hb*2, msb -> Carry
	rol PSTACK - 3, x ; dividend+1	
	rol remainder	;remainder lb & hb * 2 + msb from carry
	rol remainder+1
	lda remainder
	sec
	sbc PSTACK - 2, x ; divisor	;substract divisor to see if it fits in
	tay	        ;lb result -> Y, for we may need it later
	lda remainder+1
	sbc PSTACK - 1, x ; divisor+1
	bcc .skip	;if carry=0 then divisor didn't fit in yet

	sta remainder+1	;else save substraction result as new remainder,
	sty remainder	
	inc PSTACK - 4, x ; result	;and INCrement result cause divisor fit in 1 times

.skip	
	dec	TMP2
	bne .divloop	

	lda	remainder
	sta	PSTACK - 2, x
	lda	remainder + 1
	sta	PSTACK - 1, x
	jmp	SWAP

; =
	!word	LINK
	!set	LINK = * - 2
	!byte	1
	!text	"="
EQU
	dex
	dex
	lda	PSTACK + 1, x
	cmp	PSTACK - 1, x
	bne	+
	lda	PSTACK + 0, x
	cmp	PSTACK - 2, x
	bne	+
	lda	#$ff
	jmp	++
+
	lda	#0
++
	sta	PSTACK - 1, x
	sta	PSTACK - 2, x
	+NEXT

; <> - TODO

; <
	!word	LINK
	!set	LINK = * - 2
	!byte	1
	!text	"<"
LT
	dex
	dex
	lda	PSTACK + 1, x
	cmp	PSTACK - 1, x
	bmi	+ ; FIXME - bcc/bcs
	lda	PSTACK + 0, x
	cmp	PSTACK - 2, x
	bmi	+ ; FIXME - bcc/bcs
	lda	#0
	jmp	++
+
	lda	#$ff
++
	sta	PSTACK - 1, x
	sta	PSTACK - 2, x
	+NEXT

; >
	!word	LINK
	!set	LINK = * - 2
	!byte	1
	!text	">"
GT
	dex
	dex
	lda	PSTACK - 1, x
	cmp	PSTACK + 1, x
	bmi	+ ; FIXME - bcc/bcs
	lda	PSTACK - 2, x
	cmp	PSTACK - 0, x
	bmi	+ ; FIXME - bcc/bcs
	lda	#0
	jmp	++
+
	lda	#$ff
++
	sta	PSTACK - 1, x
	sta	PSTACK - 2, x
	+NEXT

; <= - TODO
; >= - TODO

; 0=
	!word	LINK
	!set	LINK = * - 2
	!byte	2
	!text	"0="
ZEQU
	lda	PSTACK - 1, x
	bne +
	lda	PSTACK - 2, x
	bne +
	lda	#$ff
	jmp	++
+
	lda	#0
++
	sta	PSTACK - 1, x
	sta	PSTACK - 2, x
	+NEXT

; 0<>
	!word	LINK
	!set	LINK = * - 2
	!byte	3
	!text	"0<>"
ZNEQU
	lda	PSTACK - 1, x
	bne +
	lda	PSTACK - 2, x
	bne +
	lda	#0
	jmp	++
+
	lda	#$ff
++
	sta	PSTACK - 1, x
	sta	PSTACK - 2, x
	+NEXT

; 0< - TODO
; 0> - TODO
; 0<= - TODO
; 0>= - TODO

; AND
	!word	LINK
	!set	LINK = * - 2
	!byte	3
	!text	"and"
AAND
	lda	PSTACK - 1, x
	and PSTACK - 3, x
	sta PSTACK - 3, x

	lda	PSTACK - 2, x
	and PSTACK - 4, x
	sta PSTACK - 4, x

	dex
	dex

	+NEXT

; OR
	!word	LINK
	!set	LINK = * - 2
	!byte	2
	!text	"or"
OR
	lda	PSTACK - 1, x
	ora PSTACK - 3, x
	sta PSTACK - 3, x

	lda	PSTACK - 2, x
	ora PSTACK - 4, x
	sta PSTACK - 4, x

	dex
	dex

	+NEXT

; XOR
	!word	LINK
	!set	LINK = * - 2
	!byte	3
	!text	"xor"
XOR
	lda	PSTACK - 1, x
	eor PSTACK - 3, x
	sta PSTACK - 3, x

	lda	PSTACK - 2, x
	eor PSTACK - 4, x
	sta PSTACK - 4, x

	dex
	dex

	+NEXT

; NOT
	!word	LINK
	!set	LINK = * - 2
	!byte	3
	!text	"not"
NOT
	lda	PSTACK - 1, x
	eor #$ff
	sta PSTACK - 1, x

	lda	PSTACK - 2, x
	eor #$ff
	sta PSTACK - 2, x

	+NEXT

; !
	!word	LINK
	!set	LINK = * - 2
	!byte	1
	!text	"!"
STORE
	lda	PSTACK - 1, x ; dst
	sta TMP + 1
	lda	PSTACK - 2, x
	sta TMP
	
	ldy	#0
	lda PSTACK - 4, x
	sta	(TMP), y	
	iny
	lda PSTACK - 3, x
	sta	(TMP), y	

	+dex4

	+NEXT

; @
	!word	LINK
	!set	LINK = * - 2
	!byte	1
	!text	"@"
FETCH
	lda	PSTACK - 1, x ; src
	sta TMP + 1
	lda	PSTACK - 2, x
	sta TMP
	
	ldy	#0
	lda	(TMP), y	
	sta	PSTACK - 2, x
	iny
	lda	(TMP), y
	sta	PSTACK - 1, x

	dex
	dex

	+NEXT

; +! - TODO
; -! - TODO

; C!
	!word	LINK
	!set	LINK = * - 2
	!byte	2
	!text	"c!"
STOREBYTE
	lda	PSTACK - 1, x ; dst
	sta TMP + 1
	lda	PSTACK - 2, x
	sta TMP
	
	ldy	#0
	lda PSTACK - 4, x
	sta	(TMP), y	

	+dex4

	+NEXT

; C@
	!word	LINK
	!set	LINK = * - 2
	!byte	2
	!text	"c@"
FETCHBYTE
	lda	PSTACK - 1, x ; dst
	sta TMP + 1
	lda	PSTACK - 2, x
	sta TMP
	
	ldy	#0
	lda PSTACK - 3, x
	sta	(TMP), y	
	tya
	sta	PSTACK - 4, x

	dex
	dex

	+NEXT

; C$C! - TODO
; CMOVE - TODO

; ---------- variables

; S0 - TODO

; STATE - Is the interpreter executing code (0) or compiling a word (non-zero)?
	!word	LINK
	!set	LINK = * - 2
	!byte 5
	!text	"state"
	+VAR_CODE	STATE
STATE
	!word	0

; HERE - points to the next free byte of memory. When compiling, compiled words go here.
	!word	LINK
	!set	LINK = * - 2
	!byte 4
	!text	"here"
HERE_CODE
	+VAR_CODE	HERE
HERE
	!word	LATEST + 2

; R0 - the address of the top of the return stack.
	!word	LINK
	!set	LINK = * - 2
	!byte 2
	!text	"r0"
R0
	inx
	inx

	stx	tmp_x
	tsx
	txa
	ldx	tmp_x

	sta	PSTACK - 2, x
	lda	#1
	sta	PSTACK - 1, x

	rts

; ------------ return stack

; >R
	!word	LINK
	!set	LINK = * - 2
	!byte	2
	!text	">r"
TOR
	pla
	sta	TMP
	pla
	sta	TMP + 1

	lda	PSTACK - 2, x
	pha
	lda	PSTACK - 1, x
	pha
	dex
	dex

	lda	TMP + 1
	pha
	lda	TMP
	pha

	rts

; R>
	!word	LINK
	!set	LINK = * - 2
	!byte	2
	!text	"r>"
FROMR
	inx
	inx
	pla
	sta	PSTACK - 1, x
	pla
	lda	PSTACK - 2, x
	+NEXT

; RDROP
	!word	LINK
	!set	LINK = * - 2
	!byte	5
	!text	"rdrop"
RDROP
	pla
	pla
	+NEXT


; ------------ i/o

; EMIT
	!word	LINK
	!set	LINK = * - 2
	!byte	4
	!text	"emit"
EMIT
	dex
	dex
	lda	PSTACK, x
	jmp	print_char

print_char
	stx	tmp_x
	jsr	PUTCHR
	ldx	tmp_x
	rts

print_hex_nibble
	cmp	#10

	bcc	.dec
	; hex
	clc
	adc	#$41 - 10
	jmp	+

.dec
	eor	#$30

+

	stx	tmp_x
	jsr	PUTCHR
	ldx	tmp_x

	rts

; . - display number on screen
	!word	LINK
	!set	LINK = * - 2
	!byte	1
	!text	"."
DOT
	lda	PSTACK - 1, x
	lsr
	lsr
	lsr
	lsr
	jsr print_hex_nibble

	lda	PSTACK - 1, x
	and	#$f
	jsr	print_hex_nibble

	lda	PSTACK - 2, x
	lsr
	lsr
	lsr
	lsr
	jsr	print_hex_nibble
	
	lda	PSTACK - 2, x
	and	#$f
	jsr	print_hex_nibble

	lda	#K_SPACE
	jsr	print_char

	dex
	dex

	rts

TIB
	!fill 33

IM_EXECUTE = 0 ; yellow
IM_COMPILE = 1 ; green
IM_DEFINE = 2 ; red
IM_VARIABLE = 3 ; magenta

INPUT_MODE
	!byte	IM_EXECUTE

INPUT_HEX
	!byte	0

tmp_x
	!byte	0

color_table
		;	execute		compile		define		variable
	!byte	C_YELLOW, 	C_GREEN, 	C_RED,		C_MAGENTA	; word

!ct	scr

input_type_desc
	!text	"a-9 hex "

!ct	pet

input_type_desc_col = 36
input_type_desc_row = 24

; wastes TMP, y
update_input_type_desc
	txa ; save x
	pha

	lda	INPUT_HEX
	asl
	asl

	clc
	adc	#<input_type_desc
	sta	TMP
	lda	#>input_type_desc
	sta	TMP + 1

desc_pos = $400 + 40 * 24 + 37
	ldy	#0
	lda	(TMP), y
	sta	desc_pos
	iny
	lda	(TMP), y
	sta	desc_pos + 1
	iny
	lda	(TMP), y
	sta	desc_pos + 2
	
	pla ; restore x
	tax

	rts

update_color
	ldy	INPUT_MODE
	lda	color_table, y
	sta	BLINK_COLOR
desc_color_pos = $d800 + 40 * 24 + 37
	sta	desc_color_pos
	sta	desc_color_pos + 1
	sta	desc_color_pos + 2

	jmp	update_input_type_desc

; input key in a
handle_input_char
	jsr	print_char

	; put char in TIB
.dst
	sta $f00d
	inc	.dst + 1
	bne	+
	inc	.dst + 2
+
	rts

handle_input_digit_hex
	; make space for a new hex digit...
	asl	TMP
	rol	TMP + 1
	asl	TMP
	rol	TMP + 1
	asl	TMP
	rol	TMP + 1
	asl	TMP
	rol	TMP + 1

	sec
	sbc	#$30 ; fix for 0-9

	cmp	#$10 ; fix for a-f
	bcc	+
	sbc	#7
+
	eor	TMP ; eor in the new hex digit
	sta	TMP

	rts

handle_input_digit_dec
	pha

	; multiply existing number by 10...
	inx
	inx
	inx
	inx

	lda	TMP
	sta	PSTACK - 4, x
	lda	TMP + 1
	sta	PSTACK - 3, x
	
	lda	#10
	sta	PSTACK - 2, x
	lda	#0
	sta	PSTACK - 1, x

	lda	TMP2
	pha
	lda	TMP2 + 1
	pha

	jsr	MUL

	pla
	sta	TMP2 + 1
	pla
	sta	TMP2

	lda	PSTACK - 2, x
	sta	TMP
	lda	PSTACK - 1, x
	sta	TMP + 1

	; add the entered digit...
	pla

	sec
	sbc	#$30 ; fix for 0-9

	inx
	inx
	sta	PSTACK - 2, x
	lda	#0
	sta	PSTACK - 1, x

	jsr	ADD

	lda	PSTACK - 2, x
	sta	TMP
	lda	PSTACK - 1, x
	sta	TMP + 1

	dex
	dex

	rts

_accept_char_table
	!text	"0123456789abcdefghijklmnopqrstuvwxyz-.:;=*+-!#$@%&/\"
	!byte	0

_accept_hex_table
	!text	"0123456789abcdef"
	!byte	0

handle_return_flip_input_type
	cmp	#K_RETURN
	bne	++
	; switch input mode...
	pha ; save a
	lda	.entered_chars_count
	bne	+

	lda	INPUT_HEX
	eor	#1
	sta	INPUT_HEX
	sta	$c7

	jsr	update_color
	pla ; drop a

	pla ; discard return addresses, go to interpret
	pla
	pla
	pla
	jmp	INTERPRET
+
	pla ; restore a
++
	rts

; WORD
	!word	LINK
	!set	LINK = * - 2
	!byte	4
	!text	"word"
WORD
	; prepare text input
	lda	#<(TIB + 1) 
	sta	.dst + 1
	lda	#>(TIB + 1)
	sta	.dst + 2
	lda	#0
	sta	.entered_chars_count
	
	lda	INPUT_HEX
	bne	+
	lda	#<_accept_char_table
	sta	TMP2
	lda	#>_accept_char_table
	sta	TMP2 + 1
	jmp	++
+	; hex
	lda	#<_accept_hex_table
	sta	TMP2
	lda	#>_accept_hex_table
	sta	TMP2 + 1
++

-
	+reset_cursor

	stx	tmp_x
	jsr	GETCHR
	ldx	tmp_x
	ora	#0
	beq	-
	cmp #K_SPACE
	beq .space

	cmp	#K_BACKSPACE
	bne	+
	jsr	handle_backspace
	jmp	WORD
+

	jsr	handle_return_flip_input_type

	jsr	_allowed_char
	ora	#0
	beq	-

	pha
	lda	INPUT_MODE
	cmp	#IM_DEFINE
	bne	+
	lda	.entered_chars_count
	bne	+
	+reset_cursor
	lda	#K_SPACE
	jsr	print_char ; CR on starting a new definition
	lda	#K_RETURN
	jsr	print_char ; CR on starting a new definition
+
	pla
	inc	.entered_chars_count

	jsr	handle_input_char

	jmp	-

.space
	lda	.entered_chars_count
	bne	++
	inc	INPUT_MODE

	lda	INPUT_MODE
	and	#3
	sta	INPUT_MODE
	lda	INPUT_HEX
	beq	+
	lda	INPUT_MODE
	and	#1 ; only yellow/green allowed for hex words
	sta	INPUT_MODE
+

	jsr	update_color
	pla ; discard return address
	pla
	jmp	INTERPRET

++
	lda	#0
	sta	K_REVERSE
	lda	#K_SPACE
	stx	tmp_x
	jsr	PUTCHR
	ldx	tmp_x

	; return text string
	lda	.entered_chars_count
	sta TIB 

	inx
	inx

	lda	#<TIB
	sta	PSTACK - 2, x
	lda	#>TIB
	sta	PSTACK - 1, x
+
	rts

; input in a... returned a = 0 means not accepted

_allowed_char
	sta	.inchar + 1

	ldy	#0
-
	lda	(TMP2), y
	beq	+

.inchar
	cmp	#0	; inchar... overwritten
	beq	+

	iny
	jmp	-
+
	rts

.entered_chars_count
	!byte	0

handle_backspace
-
	lda	.entered_chars_count
	beq	+

	lda	#K_BACKSPACE
	jsr	print_char

	dec	.entered_chars_count

	jmp	-
+
	rts

; convert a text string on the stack to an int
word_to_number
	lda	#0
	sta	TMP
	sta	TMP + 1
	tay

	lda	PSTACK - 2, x
	sta	TMP2
	lda	PSTACK - 1, x
	sta	TMP2 + 1

	lda	(TMP2), y
	sta	.entered_chars_count
	iny

	lda	INPUT_HEX
	bne	+
	; dec
	lda	#<handle_input_digit_dec
	sta	.handle_input_digit + 1
	lda	#>handle_input_digit_dec
	sta	.handle_input_digit + 2
	jmp	++
+	; hex
	lda	#<handle_input_digit_hex
	sta	.handle_input_digit + 1
	lda	#>handle_input_digit_hex
	sta	.handle_input_digit + 2
++

-
	lda	.entered_chars_count
	beq	+

	lda	(TMP2), y
.handle_input_digit
	jsr	$1234 ; overwrite

	dec	.entered_chars_count
	iny

	jmp	-
+

	lda	TMP
	sta	PSTACK - 2, x
	lda	TMP + 1
	sta	PSTACK - 1, x

	rts

; FIND
	!word	LINK
	!set	LINK = * - 2
	!byte	4
	!text	"find"
FIND
	lda	#<LATEST
	sta	TMP2
	lda	#>LATEST
	sta	TMP2 + 1
	; TMP2 now contains pointer to pointer to the most recently defined dictionary word.
	ldy	#0
	lda	(TMP2), y
	sta	TMP
	iny
	lda	(TMP2), y
	sta	TMP + 1
	; TMP now contains pointer to the most recently defined dictionary word.

	lda	PSTACK - 1, x
	sta	TMP2 + 1
	lda	PSTACK - 2, x
	sta	TMP2 ; TMP2 contains pointer to find string

.examine_word
	ldy	#0
	lda	(TMP2), y ; get length of find string
	and	#STRLEN_MASK
	sta	.strlen

	ldy	#2
	lda	(TMP), y ; get string length of dictionary word
	and	#STRLEN_MASK | F_HIDDEN ; include hidden flag... so we don't find the hidden words.
	cmp	.strlen
	bne	.word_not_equal

	; equal strlen, now compare strings...
	ldy	#1
-
	iny
	iny
	lda	(TMP), y ; get char of dictionary string
	dey
	dey
	cmp	(TMP2), y ; compare with find string
	bne	.word_not_equal
	dec	.strlen
	beq	.word_is_equal

	iny ; advance char ptr
	jmp	-
	
.word_is_equal
	; return address to dictionary word
	lda	TMP
	sta	PSTACK - 2, x
	lda	TMP + 1
	sta	PSTACK - 1, x
	lda	#1
	rts

.word_not_equal
	; ok... no match, advance the linked list.
	ldy	#0
	lda	(TMP), y
	pha
	iny
	lda	(TMP), y
	sta	TMP + 1
	pla
	sta	TMP

	; TMP now contains new dictionary word.
	lda	TMP
	ora	TMP + 1
	beq	.not_found ; null link, give up
	jmp	.examine_word

.not_found
	; a is zero
	sta	PSTACK - 2, x
	sta	PSTACK - 1, x
	rts
	
.strlen
	!byte 0

; >CFA
	!word	LINK
	!set	LINK = * - 2
	!byte	4
	!text	">cfa"
TCFA
	lda	PSTACK - 1, x
	sta	TMP + 1
	lda	PSTACK - 2, x
	sta TMP
	; TMP contains pointer to word
	ldy	#2
	lda	(TMP), y ; a contains string length + mask
	and	#STRLEN_MASK
	clc
	adc	#3 ; offset for link + string length
	sta	.addend + 1
	lda	PSTACK - 2, x
.addend
	adc	#0
	sta	PSTACK - 2, x
	bcc	+
	inc	PSTACK - 1, x
+
	rts

; EXEC
	!word	LINK
	!set	LINK = * - 2
	!byte	4
	!text	"exec"
EXEC
	lda	PSTACK - 2, x
	sta TMP
	lda	PSTACK - 1, x
	sta	TMP + 1
	dex
	dex
	jmp	(TMP)

; INTERPRET
	!word	LINK
	!set	LINK = * - 2
	!byte	9
	!text	"interpret"
INTERPRET
	jsr	update_color

	jsr WORD ; push string to stack

	lda	INPUT_MODE
	cmp	#IM_DEFINE
	bne	+
	; ah... a new definition word!
	lda	#IM_COMPILE ; switch back to compile mode
	sta	INPUT_MODE
	jsr	update_color
	jsr	CREATE ; create dictionary entry / header
	jmp	RBRAC ; go into compile mode
+
	jsr	DUP
	lda	INPUT_HEX
	bne	.number
	jsr	FIND ; is it in the dictionary?
	beq	.number ; not found... parse as number

	jsr	SWAP
	jsr	DROP

	lda	STATE ; compiling?
	beq	.execute ; no... execute it

	lda	PSTACK - 2, x
	sta	TMP
	lda	PSTACK - 1, x
	sta TMP + 1

	; skip link
	inc	TMP
	bne	+
	inc TMP + 1
+
	inc TMP
	bne +
	inc	TMP + 1
+

	; is it immediate?
	ldy	#0
	lda	(TMP), y
	and	#F_IMMED
	bne	.execute ; yes... execute

	; no... compile
	jsr TCFA ; fetch code address
	jmp	COMMA

.execute
	jsr TCFA ; fetch code address
	jmp EXEC ; execute it!

.number
	jsr	DROP
	jsr word_to_number ; push number to stack
	lda	STATE ; compiling?
	bne	.compile_number 
	
	; no... leave it on stack
	rts

.compile_number
	dex
	dex

	lda	#OP_INX
	jsr	_compile_byte
	lda	#OP_INX
	jsr	_compile_byte

	lda	#OP_LDA_I
	jsr	_compile_byte
	lda	PSTACK - 0, x
	jsr	_compile_byte

	lda	#OP_STA_AX
	jsr	_compile_byte
	lda	#<(PSTACK - 2)
	jsr	_compile_byte
	lda	#>(PSTACK - 2)
	jsr	_compile_byte

	lda	#OP_LDA_I
	jsr	_compile_byte
	lda	PSTACK + 1, x
	jsr	_compile_byte

	lda	#OP_STA_AX
	jsr	_compile_byte
	lda	#<(PSTACK - 1)
	jsr	_compile_byte
	lda	#>(PSTACK - 1)
	jmp	_compile_byte

.unknown_lit_err
	; not found !!!
	lda	#2
	sta	$d020
	jsr	handle_backspace
	lda	#K_BACKSPACE
	jsr	print_char
	lda	#0
	sta	$d020

	dex
	dex
	rts

; LIT
	!word	LINK
	!set	LINK = * - 2
	!byte	3
	!text	"lit"
LIT
	; pop return address
	pla
	sta	TMP
	pla
	sta	TMP + 1

	; grow stack
	inx
	inx

	; copy literal to stack
	ldy	#1 ; offset by one to make TMP + y point to the literal
	lda	(TMP), y
	sta	PSTACK - 2, x

	iny
	lda	(TMP), y
	sta	PSTACK - 1, x

	tya
	dey
	clc
	adc TMP	
	bcc	+
	inc	TMP + 1
+
	sta	TMP

	; return
	lda	TMP + 1
	pha
	lda	TMP
	pha
	rts

; QUIT
	!word	LINK
	!set	LINK = * - 2
	!byte	4
	!text	"quit"
QUIT
	jsr	INTERPRET
	jmp	QUIT

; CREATE
	!word	LINK
	!set	LINK = * - 2
	!byte	6
	!text	"create"
CREATE
	; store link in header. TMP = dst
	lda	HERE
	sta	TMP
	lda	HERE + 1
	sta	TMP + 1

	ldy	#0
	lda	LATEST
	sta	(TMP), y

	inc	TMP
	bne	+
	inc	TMP + 1
+
	lda	LATEST + 1
	sta	(TMP), y

	inc	TMP
	bne	+
	inc	TMP + 1
+

	; store length byte in header. TMP2 = src
	lda	PSTACK - 2, x
	sta	TMP2
	lda	PSTACK - 1, x
	sta	TMP2 + 1
	lda	(TMP2), y
	ora	#F_HIDDEN
	sta	(TMP), y	

	; save stack ptr to use x as loop counter
	txa
	pha

	; copy string
	lda	(TMP2), y
	tax
-
	iny
	lda	(TMP2), y
	sta	(TMP), y

	dex
	bne	-

	; update LATEST
	lda	HERE
	sta	LATEST
	lda	HERE + 1
	sta	LATEST + 1
	
	; update HERE
	iny
	tya
	clc
	adc	TMP
	sta	HERE
	bcc	+
	inc	HERE + 1
+

	; restore stack ptr
	pla
	tax

	dex
	dex

	rts

; COMMA - generate function call to the next word
	!word	LINK
	!set	LINK = * - 2
	!byte	1
	!text	","
COMMA
	lda	#OP_JSR
	jsr	_compile_byte

	lda	HERE
	sta	TMP
	lda	HERE + 1
	sta	TMP + 1

	ldy	#0
	lda	PSTACK - 2, x
	sta	(TMP), y
	iny
	lda	PSTACK - 1, x
	sta	(TMP), y

	; update HERE
	inc	HERE
	bne	+
	inc HERE + 1
+
	inc	HERE
	bne +
	inc HERE + 1
+
	dex
	dex
	rts

; LBRAC
	!word	LINK
	!set	LINK = * - 2
	!byte	1 | F_IMMED
	!text	"["
LBRAC
	lda	#0
	sta	STATE
	rts

; RBRAC
	!word	LINK
	!set	LINK = * - 2
	!byte	1
	!text	"]"
RBRAC
	lda	#1
	sta	STATE
	rts

; input in a... wastes TMP
_compile_byte
	pha
	lda	HERE
	sta	TMP
	lda	HERE + 1
	sta	TMP + 1

	ldy	#0
	pla
	sta	(TMP), y

	inc	HERE
	bne	+
	inc	HERE + 1
+
	rts

; SEMICOLON
	!word	LINK
	!set	LINK = * - 2
	!byte	1 | F_IMMED
	!text	";"
SEMICOLON
	lda	#OP_RTS ; this should be changed to replacing last jsr with jmp...
	jsr	_compile_byte

	; make the word findable again (clear F_HIDDEN)
	lda	LATEST
	sta	TMP
	lda	LATEST + 1
	sta	TMP + 1
	ldy	#2
	lda	(TMP), y
	and	#!F_HIDDEN
	sta	(TMP), y
	jmp	LBRAC ; go back to immediate mode

; BRANCH
	!word	LINK
	!set	LINK = * - 2
	!byte	6
	!text	"BRANCH"
BRANCH
	; pop return address
	pla
	sta	TMP
	pla
	sta	TMP + 1

	; copy offset to TMP2
	ldy	#1
	lda	(TMP), y
	sta	TMP2
	iny
	lda	(TMP), y
	sta	TMP2 + 1

	; make TMP point at the next instruction
	lda	TMP
	clc
	adc	#3 ; skip 6510 rts offset, offset word
	bcc	+
	inc	TMP + 1
+
	; sta	TMP

	; add offset (TMP2)
	; lda	TMP
	clc
	adc TMP2
	sta	TMP

	lda	TMP + 1
	adc	TMP2 + 1

	; return
	pha
	lda	TMP
	pha
	rts

; 0BRANCH
	!word	LINK
	!set	LINK = * - 2
	!byte	7
	!text	"0BRANCH"
ZBRANCH
	dex
	dex
	lda	PSTACK + 1, x
	bne .dont_branch
	lda	PSTACK + 0, x
	beq BRANCH

.dont_branch ; skip the offset and return...
	; pop return address
	pla
	clc
	adc	#3
	sta	.retaddr + 1
	pla
	sta	.retaddr + 2
	bcc	+
	inc	.retaddr + 2
+

.retaddr
	jmp	1234 ; overwrite

; TICK
	!word	LINK
	!set	LINK = * - 2
	!byte	1
	!text	"'"
TICK
	jmp	TICK
	stx	tmp_x

	tsx
	stx	.msb + 1
	stx	.msb2 + 1
	inx
	stx	.lsb + 1
	stx	.lsb2 + 1

	ldx tmp_x

.lsb
	lda	$123 ; overwrite
	sta	TMP

.msb
	lda	$123 ; overwrite
	sta	TMP + 1

	; make TMP point to the following word...
	inc	TMP
	bne	+
	inc	TMP + 1	
+

	ldy	#0
	inx
	inx
	lda	(TMP), y
	sta	PSTACK - 2, x

	inc	TMP
	bne	+
	inc	TMP + 1	
+

	lda	(TMP), y
	sta	PSTACK - 1, x

	; fix up return address
	lda	TMP
.lsb2
	sta	$123

	lda	TMP + 1
.msb2
	sta	$123

	rts

; -----------

; LATEST - points to the most recently defined dictionary word.
	!word	LINK
	!set	LINK = * - 2
	!byte 6
	!text	"latest"
	+VAR_CODE	LATEST
LATEST
	!word	LINK

