;The MIT License
;
;Copyright (c) 2008-2009 Johan Kotlinski, Mats Andren
;
;Permission is hereby granted, free of charge, to any person obtaining a copy
;of this software and associated documentation files (the "Software"), to deal
;in the Software without restriction, including without limitation the rights
;to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
;copies of the Software, and to permit persons to whom the Software is
;furnished to do so, subject to the following conditions:
;
;The above copyright notice and this permission notice shall be included in
;all copies or substantial portions of the Software.
;
;THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
;IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
;FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
;AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
;LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
;OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
;THE SOFTWARE.


; ACME assembler

!cpu 6510
!to "durexforth.prg", cbm	; set output file and format

F_IMMED = $80
F_HIDDEN = $40
STRLEN_MASK = $3f

IP = $2e
TMP = $30
TMP2 = $32
TMP3 = $34

OP_JSR = $20
OP_RTS = $60
OP_LDA_I = $a9
OP_STA_AX = $9d
OP_dex = $e8

STACK_START = $74

; X = PSP
; SP = RSP

; kernal defs

CURSOR_BLINK = $cc ; 0 = enable; 1 = disable

GETCHR = $ffe4 ; get char from kbd
PUTCHR = $ffd2 ; put char

; disk i/o
READST = $ffb7
CHRIN = $ffcf
CHROUT = $ffd2
CLOSE = $ffc3
CHKIN = $ffc6
CHKOUT = $ffc9
SETNAM = $ffbd
SETLFS = $ffba
OPEN = $ffc0
WRITEFILENO = $f

BLINK_COLOR = $286

K_F1 = $85
K_F3 = $86
K_BACKSPACE = $14
K_RETURN = $d
K_CLRSCR = $93
K_SPACE = ' '
K_REVERSE = $c7
K_DOWN = $11
K_RIGHT = $1d
K_UP = $91
K_LEFT = $9d

C_WHITE = 1
C_YELLOW = 7
C_GREEN = 5
C_LT_GREEN = 13
C_BEIGE = 10
C_ORANGE = 8
C_RED = 2
C_MAGENTA = 4
C_LT_BLUE = 14
C_BLUE = 6
C_CYAN = 3
C_PURPLE = 4

; -------- program start

*= $801 ; start at c64 basic start

!byte $b, $08, $EF, $00, $9E, $32, $30, $36,$31, $00, $00, $00 ; basic header

!ct pet

BORDER_COLOR = 0
SCREEN_COLOR = 0
	
	; set up restore key
	sei
	lda	#<restore_handler
	sta $318
	lda	#>restore_handler
	sta $319
	cli

	; clrscr
	lda #K_CLRSCR
	jsr PUTCHR

	lda	#%00010110 ; lowercase
	sta	$d018

	lda	#BORDER_COLOR
	sta	$d020
	lda	#SCREEN_COLOR
	sta	$d021
	lda	#1
	sta	CURSOR_BLINK

	lda	_START
	ora	_START + 1
	bne	reset
	; first time ever app is started...
	jsr	loadbase
	jsr	reset_start
+
reset
	lda	#BORDER_COLOR
	sta	$d020
	lda	#SCREEN_COLOR
	sta	$d021

	lda	#C_YELLOW
	sta	BLINK_COLOR

	jsr	clrcol

	lda #0
	sta	_BLINK
	sta CURSOR_BLINK
	lda	#1
	sta	_LINEBUF
	lda	#$40 ; no key repeat
	sta	$28a

	lda	#<_START
	sta IP
	lda #>_START
	sta IP + 1

	ldx	#STACK_START

	jmp	NEXT_IMPL

print_ok
	lda	#'o'
	jsr	PUTCHR
	lda	#'k'
	jsr	PUTCHR
	lda	#$d
	jsr	PUTCHR
	jmp	NEXT_IMPL

restore_handler
	cli
	jsr	reset_start
	jmp reset

reset_start
	lda	#<print_ok
	sta	_START
	lda	#>print_ok
	sta	_START + 1
	rts

clrcol
	lda	#C_YELLOW
	ldx	#0
-	sta $d800, x
	sta $d900, x
	sta $da00, x
	sta $db00, x
	dex
	bne	-
	rts

; ----------- macros

!macro NEXT {
	jmp	NEXT_IMPL
}

!macro VAR_CODE .word {
	dex
	dex
	lda	#<.word
	sta	0, x
	lda	#>.word
	sta	1, x
	+NEXT
}

; ---------- words

!set LINK = 0

__DOCOL
	lda	IP
	sta	TMP
	lda	IP + 1
	sta	TMP + 1

	pla
	sta	IP
	pla
	sta	IP + 1

	; adjust for weird return address after jsr...
	inc	IP
	bne +
	inc	IP + 1
+

	; push old IP to return stack
	lda	TMP
	pha
	lda	TMP + 1
	pha

	; fall through...

NEXT_IMPL

	; (IP) -> W
	ldy	#0
	lda	(IP), y
	sta	++ + 1
	iny
	lda	(IP), y
	sta	++ + 2

	; IP + 2 -> IP
	lda	IP
	clc
	adc	#2
	sta	IP
	bcc +
	inc	IP + 1
+

++
	jmp	0

; START - points to the code of the startup word.
	!word	LINK
	!set	LINK = * - 2
	!byte 5
	!text	"start"
	+VAR_CODE	_START
_START
	!word	0
	!word	QUIT

; DROP
	!word	LINK
	!set	LINK = * - 2
	!byte	4
	!text	"drop"
DROP
	inx
	inx
	+NEXT

; SWAP
	!word	LINK
	!set	LINK = * - 2
	!byte	4
	!text	"swap"
SWAP
	ldy	1, x
	lda	3, x
	sta 1, x
	tya
	sta	3, x

	ldy	0, x
	lda	2, x
	sta 0, x
	tya
	sta	2, x
	+NEXT

; DUP
	!word	LINK
	!set	LINK = * - 2
	!byte	3
	!text	"dup"
DUP
	jsr	_DUP
	+NEXT

_DUP
	dex
	dex

	lda	3, x
	sta	1, x
	lda	2, x
	sta	0, x
	rts

; OVER
	!word	LINK
	!set	LINK = * - 2
	!byte	4
	!text	"over"
OVER
	dex
	dex

	lda	5, x
	sta	1, x
	lda	4, x
	sta	0, x

	+NEXT

; ROT ( a b c -- b c a )
	!word	LINK
	!set	LINK = * - 2
	!byte	3
	!text	"rot"
ROT
	ldy	5, x
	lda	3, x
	sta 5, x
	lda 1, x
	sta 3, x
	tya
	sta 1, x

	ldy	4, x
	lda	2, x
	sta 4, x
	lda 0, x
	sta 2, x
	tya
	sta 0, x

	+NEXT

; 2DROP
	!word	LINK
	!set	LINK = * - 2
	!byte	5
	!text	"2drop"
TWODROP
	inx
	inx
	inx
	inx

	+NEXT

; 2DUP
	!word	LINK
	!set	LINK = * - 2
	!byte	4
	!text	"2dup"
TWODUP
	dex
	dex
	dex
	dex

	lda	5, x
	sta	1, x
	lda	4, x
	sta	0, x

	lda	7, x
	sta	3, x
	lda	6, x
	sta	2, x
	+NEXT


; 2SWAP
	!word	LINK
	!set	LINK = * - 2
	!byte	5
	!text	"2swap"
TWOSWAP

	ldy	1, x
	lda	5, x
	sta 1, x
	tya
	sta	5, x

	ldy	0, x
	lda	4, x
	sta 0, x
	tya
	sta	4, x

	ldy	3, x
	lda	7, x
	sta 3, x
	tya
	sta	7, x

	ldy	2, x
	lda	6, x
	sta 2, x
	tya
	sta	6, x

	+NEXT

; ?DUP
	!word	LINK
	!set	LINK = * - 2
	!byte	4
	!text	"?dup"
QDUP
	lda	1, x
	ora	0, x
	beq	+
	dex
	dex
	lda	3, x
	sta 1, x
	lda	2, x
	sta 0, x
+
	+NEXT

; 1+
	!word	LINK
	!set	LINK = * - 2
	!byte	2
	!text	"1+"
INCR
	inc	0, x
	bne	+
	inc	1, x
+
	+NEXT

; 1-
	!word	LINK
	!set	LINK = * - 2
	!byte	2
	!text	"1-"
DECR
	lda	0, x
	bne	+
	dec	1, x
+
	dec	0, x
	+NEXT

; +
	!word	LINK
	!set	LINK = * - 2
	!byte	1
	!text	"+"
ADD
	jsr	_ADD
	+NEXT

_ADD
	lda	0, x
	clc
	adc 2, x
	sta	2, x

	lda	1, x
	adc 3, x
	sta 3, x

	inx
	inx

	rts

; -
	!word	LINK
	!set	LINK = * - 2
	!byte	1
	!text	"-"
SUB
	lda	2, x
	sec
	sbc 0, x
	sta	2, x

	lda 3, x
	sbc 1, x
	sta 3, x

	inx
	inx

	+NEXT

; * - this calculates a 32 bit result, actually. useful? wasteful?
	!word	LINK
	!set	LINK = * - 2
	!byte	1
	!text	"*"
MUL
	jsr	_MUL
	+NEXT

; wastes TMP, TMP2, y
_MUL
product = TMP

	lda #$00
	sta product+2 ; clear upper bits of product
	sta product+3 
	ldy #$10 ; set binary count to 16 
.shift_r
	lsr 3, x ; multiplier+1 ; divide multiplier by 2 
	ror 2, x ; multiplier
	bcc rotate_r 
	lda product+2 ; get upper half of product and add multiplicand
	clc
	adc 0, x ; multiplicand
	sta product+2
	lda product+3 
	adc 1, x ; multiplicand+1
rotate_r 
	ror ; rotate partial product 
	sta product+3 
	ror product+2
	ror product+1 
	ror product 
	dey
	bne .shift_r 

	inx
	inx

	lda	product
	sta	0, x
	lda	product + 1
	sta	1, x

	rts

; /MOD
	!word	LINK
	!set	LINK = * - 2
	!byte	4
	!text	"/mod"
DIVMOD
remainder = TMP
	lda #16	        ;repeat for each bit: ...
	sta	TMP2
	lda #0	        ;preset remainder to 0
	sta remainder
	sta remainder+1

.divloop	
	asl 2, x ; dividend	;dividend lb & hb*2, msb -> Carry
	rol 3, x ; dividend+1	
	rol remainder	;remainder lb & hb * 2 + msb from carry
	rol remainder+1
	lda remainder
	sec
	sbc 0, x ; divisor	;substract divisor to see if it fits in
	tay	        ;lb result -> Y, for we may need it later
	lda remainder+1
	sbc 1, x ; divisor+1
	bcc .skip	;if carry=0 then divisor didn't fit in yet

	sta remainder+1	;else save substraction result as new remainder,
	sty remainder	
	inc 2, x ; result	;and INCrement result cause divisor fit in 1 times

.skip	
	dec	TMP2
	bne .divloop	

	lda	remainder
	sta	0, x
	lda	remainder + 1
	sta	1, x
	jmp	SWAP

; =
	!word	LINK
	!set	LINK = * - 2
	!byte	1
	!text	"="
EQU
	lda	1, x
	cmp	3, x
	bne	+
	lda	0, x
	cmp	2, x
	bne	+
	lda	#$ff
	jmp	++
+
	lda	#0
++
	inx
	inx
	sta	1, x
	sta	0, x
	+NEXT

; <
	!word	LINK
	!set	LINK = * - 2
	!byte	1
	!text	"<"
LT
	lda	1, x
	cmp	3, x
	bcc .false
	bne	.true
	; ok, msb are equal...
	lda	0, x
	cmp	2, x
	bcc	.false
	bne	.true
.false
	lda	#0
	jmp	++
.true
	lda	#$ff
++
	inx
	inx
	sta	1, x
	sta	0, x
	+NEXT

; 0=
	!word	LINK
	!set	LINK = * - 2
	!byte	2
	!text	"0="
ZEQU
	lda	1, x
	bne +
	lda	0, x
	bne +
	lda	#$ff
	jmp	++
+
	lda	#0
++
	sta	1, x
	sta	0, x
	+NEXT

; 0<>
	!word	LINK
	!set	LINK = * - 2
	!byte	3
	!text	"0<>"
ZNEQU
	lda	1, x
	bne +
	lda	0, x
	bne +
	lda	#0
	jmp	++
+
	lda	#$ff
++
	sta	1, x
	sta	0, x
	+NEXT

; AND
	!word	LINK
	!set	LINK = * - 2
	!byte	3
	!text	"and"
AAND
	lda	1, x
	and 3, x
	sta 3, x

	lda	0, x
	and 2, x
	sta 2, x

	inx
	inx

	+NEXT

; OR
	!word	LINK
	!set	LINK = * - 2
	!byte	2
	!text	"or"
OR
	lda	1, x
	ora 3, x
	sta 3, x

	lda	0, x
	ora 2, x
	sta 2, x

	inx
	inx

	+NEXT

; XOR
	!word	LINK
	!set	LINK = * - 2
	!byte	3
	!text	"xor"
XOR
	lda	1, x
	eor 3, x
	sta 3, x

	lda	0, x
	eor 2, x
	sta 2, x

	inx
	inx

	+NEXT

; NOT
	!word	LINK
	!set	LINK = * - 2
	!byte	3
	!text	"not"
NOT
	lda	1, x
	eor #$ff
	sta 1, x

	lda	0, x
	eor #$ff
	sta 0, x

	+NEXT

; !
	!word	LINK
	!set	LINK = * - 2
	!byte	1
	!text	"!"
STORE
	lda	1, x ; dst
	sta TMP + 1
	lda	0, x
	sta TMP
	
	ldy	#0
	lda 2, x
	sta	(TMP), y	
	iny
	lda 3, x
	sta	(TMP), y	

	inx
	inx
	inx
	inx
	+NEXT

; @
	!word	LINK
	!set	LINK = * - 2
	!byte	1
	!text	"@"
FETCH
	lda	1, x ; src
	sta TMP + 1
	lda	0, x
	sta TMP
	
	ldy	#0
	lda	(TMP), y	
	sta	0, x
	iny
	lda	(TMP), y
	sta	1, x

	+NEXT

; C!
	!word	LINK
	!set	LINK = * - 2
	!byte	2
	!text	"c!"
STOREBYTE
	lda	1, x ; dst
	sta TMP + 1
	lda	0, x
	sta TMP
	
	ldy	#0
	lda 2, x
	sta	(TMP), y	

	inx
	inx
	inx
	inx

	+NEXT

; C@
	!word	LINK
	!set	LINK = * - 2
	!byte	2
	!text	"c@"
FETCHBYTE
	lda	1, x ; dst
	sta TMP + 1
	lda	0, x
	sta TMP
	
	ldy	#0
	lda	(TMP), y
	sta	0, x
	tya
	sta	1, x

	+NEXT

; FILL ( val start len -- )
	!word	LINK
	!set	LINK = * - 2
	!byte	4
	!text	"fill"
FILL
	lda	4, x
	sta	.fsrc + 1
	lda	2, x
	sta	.fdst + 1
	lda	3, x
	sta	.fdst + 2
	lda	0, x
	eor	#$ff
	sta	TMP
	lda	1, x
	eor	#$ff
	sta	TMP + 1

	inx
	inx
	inx
	inx
	inx
	inx
-
	inc	TMP
	bne	+
	inc	TMP + 1
	bne	+
	+NEXT
+
.fsrc
	lda	#0 ; overwrite
.fdst
	sta	$ffff ; overwrite

	; advance
	inc	.fdst + 1
	bne	+
	inc	.fdst + 2
+
	bne	-


; CMOVE> ( src dst len -- )
	!word	LINK
	!set	LINK = * - 2
	!byte	6
	!text	"cmove>"
CMOVE_BACK
	lda	4, x
	sta	.bsrc + 1
	lda	5, x
	sta	.bsrc + 2
	lda	2, x
	sta	.bdst + 1
	lda	3, x
	sta	.bdst + 2
	lda	0, x
	eor	#$ff
	sta	TMP
	lda	1, x
	eor	#$ff
	sta	TMP + 1

	inx
	inx
	inx
	inx
	inx
	inx
-
	inc	TMP
	bne	+
	inc	TMP + 1
	bne	+
	+NEXT
+
.bsrc
	lda	$ffff ; overwrite
.bdst
	sta	$ffff ; overwrite

	; back
	dec	.bsrc + 1
	lda	.bsrc + 1
	cmp	#$ff
	bne	+
	dec	.bsrc + 2
+
	dec	.bdst + 1
	lda	.bdst + 1
	cmp	#$ff
	bne	+
	dec	.bdst + 2
+
	bne	-

; CMOVE ( src dst len -- ) forward move
	!word	LINK
	!set	LINK = * - 2
	!byte	5
	!text	"cmove"
CMOVE
	lda	4, x
	sta	.csrc + 1
	lda	5, x
	sta	.csrc + 2
	lda	2, x
	sta	.cdst + 1
	lda	3, x
	sta	.cdst + 2
	lda	0, x
	eor	#$ff
	sta	TMP
	lda	1, x
	eor	#$ff
	sta	TMP + 1

	inx
	inx
	inx
	inx
	inx
	inx
-
	inc	TMP
	bne	+
	inc	TMP + 1
	bne	+
	+NEXT
+
.csrc
	lda	$ffff ; overwrite
.cdst
	sta	$ffff ; overwrite

	; advance
	inc	.csrc + 1
	bne	+
	inc	.csrc + 2
+
	inc	.cdst + 1
	bne	+
	inc	.cdst + 2
+
	bne	-

; ---------- variables

; S0
	!word	LINK
	!set	LINK = * - 2
	!byte 3
	!text	"sp0"
	+VAR_CODE	SZERO
SZERO
	!word	STACK_START

	!word	LINK
	!set	LINK = * - 2
	!byte 12
	!text	"compile-addr"
	+VAR_CODE	COMPILE_ADDR
COMPILE_ADDR 
	!word	$5000

; STATE - Is the interpreter executing code (0) or compiling a word (non-zero)?
	!word	LINK
	!set	LINK = * - 2
	!byte 5
	!text	"state"
	+VAR_CODE	STATE
STATE
	!word	0

; COMPILE - compile from editor?
	!word	LINK
	!set	LINK = * - 2
	!byte 7
	!text	"compile"
	+VAR_CODE	COMPILE
COMPILE
	!word	0

; COMPILE-LOAD-DEPTH
	!word	LINK
	!set	LINK = * - 2
	!byte 10
	!text	"load-depth"
	+VAR_CODE	LOAD_DEPTH
LOAD_DEPTH
	!word	0

; HERE - points to the next free byte of memory. When compiling, compiled words go here.
	!word	LINK
	!set	LINK = * - 2
	!byte 4
	!text	"here"
HERE_CODE
	+VAR_CODE	HERE
HERE
	!word	_LATEST + 2

; NEXT
	!word	LINK
	!set	LINK = * - 2
	!byte 4
	!text	"next"
	+VAR_CODE	NEXT
NEXT
	!word	NEXT_IMPL

; ------------ return stack

; >R
	!word	LINK
	!set	LINK = * - 2
	!byte	2
	!text	">r"
TOR
	lda	0, x
	pha
	lda	1, x
	pha
	inx
	inx
	+NEXT

; R>
	!word	LINK
	!set	LINK = * - 2
	!byte	2
	!text	"r>"
FROMR
	dex
	dex
	pla
	sta	1, x
	pla
	sta	0, x
	+NEXT

; RFETCH
	!word	LINK
	!set	LINK = * - 2
	!byte	2
	!text	"r@"
RFETCH
	dex
	dex
	pla
	sta	1, x
	pla
	sta	0, x
	pha
	lda	1, x
	pha
	+NEXT

; RDROP
	!word	LINK
	!set	LINK = * - 2
	!byte	5
	!text	"rdrop"
RDROP
	pla
	pla
	+NEXT


; ------------ i/o

; EMIT
	!word	LINK
	!set	LINK = * - 2
	!byte	4
	!text	"emit"
EMIT
	lda	0, x
	inx
	inx
	jsr	print_char
	+NEXT

print_char_surpress_file_io
	ldy	COMPILE
	bne	+
	ldy	COMPILE + 1
	beq	print_char
+
	rts

print_char
	ldy	#20
	sty $cd ;Force new value into Cursor Blink Count down Toggle
	ldy #1
	sty $cf ;Force cursor off
	stx	tmp_x
	jsr	PUTCHR
	ldx	tmp_x
	ldy	_BLINK
	sty	CURSOR_BLINK
	rts

print_hex_nibble
	cmp	#10

	bcc	.dec
	; hex
	clc
	adc	#$41 - 10
	jmp	+

.dec
	eor	#$30

+
	jmp	print_char

print_hex_char
	pha
	lsr
	lsr
	lsr
	lsr
	jsr	print_hex_nibble
	pla
	pha
	and	#$f
	jsr	print_hex_nibble
	pla
	rts

; c.
	!word	LINK
	!set	LINK = * - 2
	!byte	2
	!text	"c."
CDOT
	lda	0, x
	lsr
	lsr
	lsr
	lsr
	jsr	print_hex_nibble
	
	lda	0, x
	and	#$f
	jsr	print_hex_nibble

	inx
	inx

	+NEXT

; . - display number on screen
	!word	LINK
	!set	LINK = * - 2
	!byte	1
	!text	"."
DOT
	jsr	_DOT
	+NEXT
_DOT
	lda	1, x
	lsr
	lsr
	lsr
	lsr
	jsr print_hex_nibble

	lda	1, x
	and	#$f
	jsr	print_hex_nibble

	lda	0, x
	lsr
	lsr
	lsr
	lsr
	jsr	print_hex_nibble
	
	lda	0, x
	and	#$f
	jsr	print_hex_nibble

	lda	#K_SPACE
	jsr	print_char

	inx
	inx

	rts

TIB
	!fill 33

tmp_x
	!byte	0

; input key in a
handle_input_char

	; put char in TIB
.dst
	sta $f00d
	inc	.dst + 1
	bne	+
	inc	.dst + 2
+
	rts

KEY_BUF_SIZE = 80
KEY_BUF
	!fill KEY_BUF_SIZE

KEY_BUF_READ_POS
	!byte 0
KEY_BUF_WRITE_POS
	!byte 0

write_key
	ldy	#<KEY_BUF
	sty	TMP
	ldy	#>KEY_BUF 
	sty	TMP + 1

	ldy	KEY_BUF_WRITE_POS
	sta	(TMP), y
	inc	KEY_BUF_WRITE_POS
	rts

; KEY... read a key from disk (if open) or keyboard.
	!word	LINK
	!set	LINK = * - 2
	!byte	3
	!text	"key"
KEY
	jsr	_KEY
	+NEXT

.unbuffered_key
-
	jsr	PULL_KEY
	ora	#0
	beq	-
	dex
	dex
	sta	0, x
	lda	#0
	sta	1, x
	rts

_KEY
	lda	_LINEBUF
	beq	.unbuffered_key
	lda	COMPILE
	ora	COMPILE + 1
	bne	.unbuffered_key
	lda	KEY_BUF_WRITE_POS
	beq	.fill_key_buf
	cmp	KEY_BUF_READ_POS
	bne	.get_from_key_buf

.fill_key_buf
	; start filling key buf... TODO: add bounds check for buffer overwrite.
	lda	#0
	sta	KEY_BUF_READ_POS
	sta	KEY_BUF_WRITE_POS

-
	jsr PULL_KEY
	ora	#0
	beq	-
	cmp	#K_RETURN
	beq	.return

	; should key be ignored?
	cmp	#K_LEFT
	beq	-
	cmp	#K_RIGHT
	beq	-
	cmp	#K_UP
	beq	-
	cmp	#K_DOWN
	beq	-

	; shift + space => space
	cmp	#$a0
	bne +
	lda	#K_SPACE	
+

	cmp	#K_BACKSPACE
	bne	+
	tay
	lda	KEY_BUF_WRITE_POS
	beq	-
	dec	KEY_BUF_WRITE_POS
	tya
	jsr	print_char_surpress_file_io
	jmp	-
+
	jsr	print_char_surpress_file_io
	
	jsr	write_key
	jmp	-

.return	;done
	lda	#K_SPACE
	jsr	print_char_surpress_file_io
	lda	#K_RETURN
	jsr	print_char_surpress_file_io

	jsr	write_key

	jmp	_KEY

.get_from_key_buf
	ldy	#<KEY_BUF
	sty	TMP
	ldy	#>KEY_BUF 
	sty	TMP + 1

	ldy	KEY_BUF_READ_POS
	lda	(TMP), y
	inc	KEY_BUF_READ_POS

	dex
	dex
	sta	0, x
	lda	#0
	sta	1, x
	rts

; get from RAM
get_from_ram
	; is done?
	lda	COMPILE
	cmp	$ae
	bne	+
	lda	COMPILE + 1
	cmp	$af
	bne	+
	rts ; yes... return eq
+
	lda	COMPILE
	sta	TMP
	lda	COMPILE + 1
	sta	TMP + 1
	ldy #0
	lda	(TMP), y
	sta	$d020
	rts

PULL_KEY
	lda	COMPILE
	ora	COMPILE + 1
	beq	.call_getchar
	jsr	get_from_ram
	beq	handle_compile_done
	inc	COMPILE
	bne	+
	inc	COMPILE + 1
+
	rts

.call_getchar
	stx	tmp_x
	jsr	GETCHR
	ldx	tmp_x
	rts

handle_compile_done
	lda	LOAD_DEPTH
	beq +
	dec	LOAD_DEPTH
	bne	++

	; compiled all files :)
	lda	_BLINK
	sta	CURSOR_BLINK
+
	lda	#BORDER_COLOR
	sta	$d020
	lda	#0
	sta	COMPILE
	sta	COMPILE + 1
	lda	#K_SPACE ; hack to get out of unbuffered reading
	rts

++	; compiled file but more to go...

	; pop old eof
	lda	1, x
	sta	$af
	lda	0, x
	sta	$ae
	; pop old COMPILE
	lda	3, x
	sta	COMPILE + 1
	lda	2, x
	sta	COMPILE
	inx
	inx
	inx
	inx
	jmp	PULL_KEY

; WRITE - write a byte to disk.
	!word	LINK
	!set	LINK = * - 2
	!byte	5
	!text	"write"
WRITE
	lda	0, x
	pha

	stx	tmp_x
	jsr	READST
	bne	werror
	pla
	jsr	CHROUT
	ldx	tmp_x
	inx
	inx
	+NEXT
werror
	pla ;Mats wonders: What the fuck is this PLA for???
	inc	$d021
	jmp	werror

; WORD
	!word	LINK
	!set	LINK = * - 2
	!byte	4
	!text	"word"
WORD
	jsr _WORD
	+NEXT

_WORD
	; prepare text input
	lda	#<(TIB + 1) 
	sta	.dst + 1
	lda	#>(TIB + 1)
	sta	.dst + 2
	lda	#0
	sta	.entered_chars_count
	
-
	jsr	_KEY
	lda	0, x
	inx
	inx

	cmp #K_RETURN
	beq .whitespace
	cmp #K_SPACE
	beq .whitespace

	cmp	#K_BACKSPACE
	bne	++
	dec	.entered_chars_count
	lda	.dst+1
	bne	+
	dec	.dst+2
+
	dec	.dst+1
	jmp	-
++

	inc	.entered_chars_count

	jsr	handle_input_char

	jmp	-

.whitespace
	; return text string
	lda	.entered_chars_count
	beq - ; whoops, nothing entered, try again...
	sta TIB 

	dex
	dex

	lda	#<TIB
	sta	0, x
	lda	#>TIB
	sta	1, x

	rts

.entered_chars_count
	!byte	0

; FIND
	!word	LINK
	!set	LINK = * - 2
	!byte	4
	!text	"find"
FIND
	jsr	_FIND
	+NEXT
_FIND
	lda	#<_LATEST
	sta	TMP2
	lda	#>_LATEST
	sta	TMP2 + 1
	; TMP2 now contains pointer to pointer to the most recently defined dictionary word.
	ldy	#0
	lda	(TMP2), y
	sta	TMP
	iny
	lda	(TMP2), y
	sta	TMP + 1
	; TMP now contains pointer to the most recently defined dictionary word.

	lda	1, x
	sta	TMP2 + 1
	lda	0, x
	sta	TMP2 ; TMP2 contains pointer to find string

.examine_word
	ldy	#0
	lda	(TMP2), y ; get length of find string
	and	#STRLEN_MASK
	sta	.strlen

	ldy	#2
	lda	(TMP), y ; get string length of dictionary word
	and	#STRLEN_MASK | F_HIDDEN ; include hidden flag... so we don't find the hidden words.
	cmp	.strlen
	bne	.word_not_equal

	; equal strlen, now compare strings...
	ldy	#1
-
	iny
	iny
	lda	(TMP), y ; get char of dictionary string
	dey
	dey
	cmp	(TMP2), y ; compare with find string
	bne	.word_not_equal
	dec	.strlen
	beq	.word_is_equal

	iny ; advance char ptr
	jmp	-
	
.word_is_equal
	; return address to dictionary word
	lda	TMP
	sta	0, x
	lda	TMP + 1
	sta	1, x
	lda	#1
	rts

.word_not_equal
	; ok... no match, advance the linked list.
	ldy	#0
	lda	(TMP), y
	pha
	iny
	lda	(TMP), y
	sta	TMP + 1
	pla
	sta	TMP

	; TMP now contains new dictionary word.
	lda	TMP
	ora	TMP + 1
	beq	.not_found ; null link, give up
	jmp	.examine_word

.not_found
	; a is zero
	sta	0, x
	sta	1, x
	rts
	
.strlen
	!byte 0

; >CFA
	!word	LINK
	!set	LINK = * - 2
	!byte	4
	!text	">cfa"
TCFA
	jsr _TCFA
	+NEXT
_TCFA
	lda	1, x
	sta	TMP + 1
	lda	0, x
	sta TMP
	; TMP contains pointer to word
	ldy	#2
	lda	(TMP), y ; a contains string length + mask
	and	#STRLEN_MASK
	clc
	adc	#3 ; offset for link + string length
	sta	.addend + 1
	lda	0, x
.addend
	adc	#0
	sta	0, x
	bcc	+
	inc	1, x
+
	rts

; EXEC
	!word	LINK
	!set	LINK = * - 2
	!byte	4
	!text	"exec"
EXEC
	lda	0, x
	sta TMP
	lda	1, x
	sta	TMP + 1
	inx
	inx
	jmp	(TMP)

; CHAR
	!word	LINK
	!set	LINK = * - 2
	!byte	4
	!text	"char"
CHAR
	jsr	_WORD
	lda	1, x
	sta	TMP + 1
	lda	0, x
	sta	TMP
	ldy	#1
	lda	(TMP), y
	sta	0, x
	lda	#0
	sta	1, x
	+NEXT

; NUMBER
	!word	LINK
	!set	LINK = * - 2
	!byte	6
	!text	"number"
NUMBER
	jsr	_NUMBER
	+NEXT

; Z set = success, clear = failed
_NUMBER ; only hex
	lda	1, x	
	sta	TMP3 + 1
	lda	0, x	
	sta	TMP3
	; TMP3 now contains a string ptr...
	ldy	#0
	lda	(TMP3), y
	sta	.chars_to_process
	; clear stack...
	lda	#0
	sta	0, x
	sta	1, x

.number_handler
	jsr	handle_input_digit_hex

	bne	.not_digit

	dec	.chars_to_process
	bne	.number_handler

.not_digit
	rts

.chars_to_process
!byte 0

handle_input_digit_hex
	; multiply stack top by 16
	dex
	dex

	lda	#16
	sta	0, x
	lda	#0
	sta	1, x

	tya
	pha
	jsr	_MUL
	pla
	tay

	; add *(++TMP3) to stack top
	iny
	lda	(TMP3), y
	clc
	adc	#-$30 ; petscii 0-9 -> 0-9

	sec ; within 0-9?
	cmp	#10
	bcc	.ok

	clc
	adc	#-$7 ; a-f...

	sec ; within a-f?
	cmp	#16
	bcs	.not_a_digit
	sec
	cmp	#10
	bcc	.not_a_digit

.ok
	dex
	dex

	sta	0, x
	lda	#0
	sta	1, x

	jsr	_ADD

	lda	#0
	rts

.not_a_digit
	lda	#1
	rts

; INTERPRET
	!word	LINK
	!set	LINK = * - 2
	!byte	9
	!text	"interpret"
INTERPRET
	jsr	_WORD ; push string to stack

	jsr	_DUP ; dup string
	jsr	_FIND ; replace string with dictionary ptr
	ora	#0
	bne	.found_word

	; didn't find word...
	; assume it's a literal number.

	inx ; drop null dictionary ptr
	inx
	jsr _NUMBER
	bne	.not_a_number

	; yep, it's a number...
	lda	STATE ; are we compiling?
	beq	.leave_number_on_stack ; no, leave number on stack
	; yes. compile literal.
	dex
	dex
	lda	#<LIT
	sta	0, x
	lda	#>LIT
	sta	1, x
	jsr	_COMMA
	jsr	_COMMA

.leave_number_on_stack
	+NEXT

.not_a_number
	jsr print_error_msg_with_tib
	ldx	#0
	stx	KEY_BUF_READ_POS
	stx	KEY_BUF_WRITE_POS
	stx	COMPILE
	stx	COMPILE + 1
	ldx	#STACK_START ; wipe stack :(
	+NEXT

.found_word
	; OK, we found a word...

	; is it immediate?
	lda	0, x
	sta	TMP
	lda	1, x
	sta	TMP + 1
	ldy	#2 ; skip link ptr, look at flags
	lda	(TMP), y
	and	#F_IMMED
	bne	.execute_word ; yes... execute it.

	lda	STATE ; are we compiling?
	beq	.execute_word ; no, execute it.

	; OK, this word should be compiled...
	jsr	_TCFA
	jsr	_COMMA
	inx ; drop string
	inx
	+NEXT

.execute_word
	jsr	_TCFA

	; copy CFA to TMP
	lda	0, x
	sta	TMP
	lda	1, x
	sta	TMP + 1
	; drop CFA + string
	inx
	inx
	inx
	inx
	jmp	(TMP)

print_error_msg_with_tib
	lda	#$12 ; reverse on
	jsr	print_char

	ldy	TIB
	lda	#<TIB
	sta	TMP
	lda	#>TIB
	sta	TMP + 1

-
	inc	TMP
	bne	+
	inc	TMP + 1
+

	tya
	pha

	ldy	#0
	lda	(TMP), y
	jsr	print_char

	pla
	tay

	dey
	bne -

	lda	#'?'
	jsr	print_char

	lda	#$92 ; reverse off
	jsr	print_char

	lda	#' '
	jsr	print_char

	rts

; JSR
	!word	LINK
	!set	LINK = * - 2
	!byte	3
	!text	"jsr"
_JSR
	lda	0, x
	sta	+ + 1
	lda	1, x
	sta	+ + 2
	stx	tmp_x
+
	jsr 0 ; overwrite
	ldx tmp_x
	inx
	inx
	+NEXT

; TICK
	!word	LINK
	!set	LINK = * - 2
	!byte	1
	!text	"'"
TICK
	jmp	LIT

; LIT
	!word	LINK
	!set	LINK = * - 2
	!byte	3
	!text	"lit"
LIT
	; grow stack
	dex
	dex

	; copy literal to stack
	ldy	#0
	lda	(IP), y
	sta	0, x

	iny
	lda	(IP), y
	sta	1, x

	; IP += 2
	clc
	lda	IP
	adc #2	
	bcc	+
	inc	IP + 1
+
	sta	IP

	+NEXT

; QUIT
	!word	LINK
	!set	LINK = * - 2
	!byte	4
	!text	"quit"
QUIT
	jsr	__DOCOL
	!word	INTERPRET
	!word	BRANCH
	!word	-4

; EXIT
	!word	LINK
	!set	LINK = * - 2
	!byte	4
	!text	"exit"
EXIT
	pla
	sta	IP + 1
	pla
	sta	IP
	+NEXT


; blink (0 = enable, 1 = disable)
	!word	LINK
	!set	LINK = * - 2
	!byte	5
	!text	"blink"
BLINK
	lda	0, x
	eor	#1
	sta	_BLINK
	sta	$cc
	inx
	inx
	+NEXT
_BLINK
	!byte	0

; CREATE ( name -- )
	!word	LINK
	!set	LINK = * - 2
	!byte	6
	!text	"create"
CREATE
	jsr	_WORD

	; store link in header. TMP = dst
	lda	HERE
	sta	TMP
	lda	HERE + 1
	sta	TMP + 1

	ldy	#0
	lda	_LATEST
	sta	(TMP), y

	inc	TMP
	bne	+
	inc	TMP + 1
+
	lda	_LATEST + 1
	sta	(TMP), y

	inc	TMP
	bne	+
	inc	TMP + 1
+

	; store length byte in header. TMP2 = src
	lda	0, x
	sta	TMP2
	lda	1, x
	sta	TMP2 + 1
	lda	(TMP2), y
	sta	(TMP), y	

	; save stack ptr to use x as loop counter
	txa
	pha

	; copy string
	lda	(TMP2), y
	tax
-
	iny
	lda	(TMP2), y
	sta	(TMP), y

	dex
	bne	-

	; update _LATEST
	lda	HERE
	sta	_LATEST
	lda	HERE + 1
	sta	_LATEST + 1
	
	; update HERE
	iny
	tya
	clc
	adc	TMP
	sta	HERE
	bcc	+
	inc	TMP + 1
+
	lda	TMP + 1
	sta	HERE + 1

	; restore stack ptr
	pla
	tax

	inx
	inx

	+NEXT

; CCOMMA - write char
	!word	LINK
	!set	LINK = * - 2
	!byte	2
	!text	"c,"
CCOMMA
	lda	HERE
	sta	TMP
	lda	HERE + 1
	sta	TMP + 1

	ldy	#0
	lda	0, x
	sta	(TMP), y

	; update HERE
	inc	HERE
	bne	+
	inc HERE + 1
+
	inx
	inx
	+NEXT

; COMMA - write word
	!word	LINK
	!set	LINK = * - 2
	!byte	1
	!text	","
COMMA
	jsr	_COMMA
	+NEXT
_COMMA
	lda	HERE
	sta	TMP
	lda	HERE + 1
	sta	TMP + 1

	ldy	#0
	lda	0, x
	sta	(TMP), y
	iny
	lda	1, x
	sta	(TMP), y

	; update HERE
	lda	HERE
	clc
	adc	#2
	sta	HERE
	bcc	+
	inc HERE + 1
+
	inx
	inx
	rts

; LBRAC
	!word	LINK
	!set	LINK = * - 2
	!byte	1 | F_IMMED
	!text	"["
LBRAC
	lda	#0
	sta	STATE
	+NEXT

; RBRAC
	!word	LINK
	!set	LINK = * - 2
	!byte	1
	!text	"]"
RBRAC
	lda	#1
	sta	STATE
	+NEXT

; SEMICOLON
	!word	LINK
	!set	LINK = * - 2
	!byte	1 | F_IMMED
	!text	";"
SEMICOLON
	jsr	__DOCOL
	!word LIT, EXIT, COMMA ; append EXIT (so that the word will return).
	!word LATEST, FETCH, HIDDEN ; unhide the word.
	!word LBRAC ; go back to IMMEDIATE mode.
	!word EXIT

; IMMEDIATE. Flip the immediate flag of the LATEST word.
	!word	LINK
	!set	LINK = * - 2
	!byte	5 | F_IMMED
	!text	"immed"
IMMED
	lda	_LATEST
	sta	TMP
	lda	_LATEST + 1
	sta	TMP + 1
	ldy	#2
	lda	(TMP), y
	eor	#F_IMMED
	sta	(TMP), y
	+NEXT

; BRANCH

	!word	LINK
	!set	LINK = * - 2
	!byte	6
	!text	"branch"
BRANCH
	; IP is now pointing to the offset by which IP should be modified...
	lda	IP
	sta	TMP
	lda	IP + 1
	sta	TMP + 1

	ldy	#0
	lda	(IP), y
	clc
	adc TMP
	sta	TMP
	bcc	+
	inc	TMP + 1
+
	iny
	lda	(IP), y
	clc
	adc	TMP + 1
	sta	IP + 1

	lda	TMP
	sta	IP

	+NEXT

; 0BRANCH
	!word	LINK
	!set	LINK = * - 2
	!byte	7
	!text	"0branch"
ZBRANCH
	lda	1, x
	ora	0, x
	bne .dont_branch
	inx
	inx
	jmp BRANCH

.dont_branch
	inx
	inx
	; skip offset
	lda	IP
	clc
	adc	#2
	sta	IP
	bcc	+
	inc	IP + 1
+
	+NEXT

; COLON
	!word	LINK
	!set	LINK = * - 2
	!byte	1
	!text	":"
COLON
	jsr	__DOCOL
	!word CREATE ; CREATE the dictionary entry / header
	!word LIT, OP_JSR, CCOMMA ; insert jmp
	!word LIT, __DOCOL, COMMA ; append __DOCOL (the codeword)
	!word LATEST, FETCH, HIDDEN ; hide word
	!word RBRAC ; enter compile mode
	!word EXIT

; input in a... wastes TMP
_compile_byte
	pha
	lda	HERE
	sta	TMP
	lda	HERE + 1
	sta	TMP + 1

	ldy	#0
	pla
	sta	(TMP), y

	inc	HERE
	bne	+
	inc	HERE + 1
+
	rts

; HIDDEN
	!word	LINK
	!set	LINK = * - 2
	!byte	6
	!text	"hidden"
HIDDEN
	lda	0, x
	sta	TMP
	lda	1, x
	sta TMP + 1

	ldy	#2 ; skip link, point to flags
	lda	(TMP), y
	eor	#F_HIDDEN ; toggle hidden flag
	sta	(TMP), y
	inx
	inx
	+NEXT

; SETCUR ( x y -- )
	!word	LINK
	!set	LINK = * - 2
	!byte	6
	!text	"setcur"
SETCUR
	lda	2, x
	tay
	lda	0, x
	stx tmp_x
	tax
	jsr	$e50a
	ldx	tmp_x
	inx
	inx
	inx
	inx
	+NEXT

; DSP@
	!word	LINK
	!set	LINK = * - 2
	!byte	3
	!text	"sp@"
SPFETCH
	txa
	dex
	dex
	sta	0, x
	lda	#0
	sta	1, x
	+NEXT

; LITSTRING
	!word	LINK
	!set	LINK = * - 2
	!byte	9
	!text	"litstring"
LITSTRING
	; grow stack
	dex
	dex

	; copy string addr to stack
	ldy	#0
	lda	IP
	sta	TMP
	sta	0, x

	iny
	lda	IP + 1
	sta	TMP + 1
	sta	1, x

	; TMP now points to string length
	dey ; y = 0
	lda	(TMP), y
	tay ; y = *TMP
	iny ; add one for length byte
	sty	.lstrlen + 1

	; skip string
	lda	IP
	clc
.lstrlen
	adc #0 ; overwritten
	sta	IP
	bcc	+
	inc	IP + 1
+
	+NEXT

; -----------

; jsr wrapper -- start

	!word	LINK
	!set	LINK = * - 2
	!byte 2
	!text	"xr"
XREG
	+VAR_CODE	_XREG
_XREG
	!word	1

	!word	LINK
	!set	LINK = * - 2
	!byte 2
	!text	"yr"
YREG
	+VAR_CODE	_YREG
_YREG
	!word	1

	!word	LINK
	!set	LINK = * - 2
	!byte 2
	!text	"ar"
AREG
	+VAR_CODE	_AREG
_AREG
	!word	1

; JSR ( addr -- )
	!word	LINK
	!set	LINK = * - 2
	!byte 8
	!text	"jsr-wrap"

	lda 0, x
	sta	.jsraddr + 1
	lda 1, x
	sta	.jsraddr + 2

	inx
	inx

	txa
	pha

	lda	_AREG
	ldx	_XREG
	ldy	_YREG

.jsraddr
	jsr	0

	sta _AREG
	stx _XREG
	sty _YREG

	pla
	tax
	+NEXT


; LINEBUF line buffering. 0 = off, 1 = on
	!word	LINK
	!set	LINK = * - 2
	!byte 7
	!text	"linebuf"
LINEBUF
	+VAR_CODE	_LINEBUF
_LINEBUF
	!word	1

; DOCOL
	!word	LINK
	!set	LINK = * - 2
	!byte 5
	!text	"docol"
DOCOL
	+VAR_CODE	__DOCOL

; CLOSEW
	!word	LINK
	!set	LINK = * - 2
	!byte 6
	!text	"closew"
CLOSEW
	stx	tmp_x
	lda	#WRITEFILENO
	jsr	CLOSE 
	ldx	#WRITEFILENO
	jsr	CHKOUT
	jsr	_errorchread
	ldx tmp_x
	+NEXT

_errorchread
        LDA #$00      ; no filename
        LDX #$00
        LDY #$00
        JSR $FFBD     ; call SETNAM
        LDA #$0F      ; file number 15
        LDX $BA       ; last used device number
        BNE +
        LDX #$08      ; default to device 8
+	   LDY #$0F      ; secondary address 15 (error channel)
        JSR $FFBA     ; call SETLFS

        JSR $FFC0     ; call OPEN
        BCS .error    ; if carry set, the file could not be opened

        LDX #$0F      ; filenumber 15
        JSR $FFC6     ; call CHKIN (file 15 now used as input)

        LDY #$00
.loop   JSR $FFB7     ; call READST (read status byte)
        BNE geof      ; either EOF or read error
        JSR $FFCF     ; call CHRIN (get a byte from file)
        JSR $FFD2     ; call CHROUT (print byte to screen)
        JMP .loop     ; next byte

geof
.glose
        LDA #$0F      ; filenumber 15
        JSR $FFC3     ; call CLOSE

        LDX #$00      ; filenumber 0 = keyboard
        JSR $FFC6     ; call CHKIN (keyboard now input device again)
        RTS
.error
        ; Akkumulator contains BASIC error code

        ; most likely error:
        ; A = $05 (DEVICE NOT PRESENT)

        ; ... error handling for open errors ...
        JMP .glose    ; even if OPEN failed, the file has to be closed


; LOADB ( filenameptr filenamelen dst -- status ) load binary file
;  - s" base" 7000 loadb #load file to 7000
;  - end of loaded file is available in $ae/$af afterwards
	!word	LINK
	!set	LINK = * - 2
	!byte 5
	!text	"loadb"
LOADB
	txa
	pha

	lda 1, x		; >destination
	sta load_binary_laddr_hi
	lda 0, x		; <destination
	sta load_binary_laddr_lo

	lda 2, x		; a filename length
	pha
	ldy 5, x 		; y >basename 
	lda 4, x		; x <basename 
	tax
	pla
	jsr	load_binary
	
	pla
	tax

	inx
	inx
	inx
	inx
	lda	load_binary_status
	sta	1, x
	sta	0, x
	beq	+
	txa
	pha
	jsr	_errorchread
	pla
	tax
+
	+NEXT

load_binary_status
	!byte	0

;load_binary_base
;	lda	#basename_end - basename
;	ldx	#<basename
;	ldy	#>basename
;	; fall through...

load_binary
	jsr .disk_io_setnamsetlfs

load_binary_laddr_lo = *+1
	ldx #$ff	;<load_address
load_binary_laddr_hi = *+1
	ldy #$ff	;>load_address
	lda #0		;0 = load to memory (no verify)
	sta	load_binary_status
	jsr $ffd5	;LOAD
	bcs .disk_io_error
	ldx #$00      ; filenumber 0 = keyboard
	jsr CHKIN     ; call CHKIN (keyboard now input device again)
 	rts

.disk_io_setnamsetlfs ;reused by both loadb and saveb
	jsr SETNAM
	lda $ba		;last used device number
	and #3		;Make 0-3 possible numbers
	ora #8		;Transform to 8-B
	tax
	lda #1
	ldy #0		;if load: 0 = load to new address, if save: 0 = dunno, but okay... 
	jmp SETLFS	;End with JMP instead of jsr/rts to save a jsr/rts pair...


.disk_io_error
	; Accumulator contains BASIC error code
	
	;... error handling ...
	ldx #$00      ; filenumber 0 = keyboard
	jsr CHKIN     ; call CHKIN (keyboard now input device again)
	lda	#1
	sta	load_binary_status
	rts

; SAVEB (save binary file)
;  - 7000 71ae s" base" saveb #save file from 7000 to 71ae (= the byte AFTER the last byte in the file)
	!word	LINK
	!set	LINK = * - 2
	!byte 5
	!text	"saveb"
SAVEB
	stx tmp_x

	lda	$ae
	pha
	lda	$af
	pha

	lda 6, x		; range begin lo
	sta $c1
	lda 7, x		; range begin hi
	sta $c2
	
	lda 4, x		; range end lo
	sta save_binary_srange_end_lo
	lda 5, x		; range end hi
	sta save_binary_srange_end_hi

	lda 0, x		; a filename length
	pha
	ldy 3, x 		; y basename hi
	lda 2, x		; x basename lo
	tax
	pla

	jsr .disk_io_setnamsetlfs
	
	;This should point to the byte AFTER the last byte in the file.
save_binary_srange_end_lo = *+1
	ldx #$ff	;load_address lo
save_binary_srange_end_hi = *+1
	ldy #$ff	;load_address hi
	lda #$c1	;tell routine that start address is located in $c1/$c2
	jsr $ffd8	;SAVE
	bcs .disk_io_error

	pla
	sta	$af
	pla
	sta	$ae

	ldx tmp_x
	inx
	inx
	inx
	inx
	inx
	inx
	inx
	inx
	+NEXT


; OPENW ( strptr strlen ) open file for writing
	!word	LINK
	!set	LINK = * - 2
	!byte 5
	!text	"openw"
OPENW
	stx	tmp_x

	lda	0, x
	ldy	3, x
	pha
	lda	2, x
	tax
	pla
	
	jsr	SETNAM
	lda	#WRITEFILENO ; file number
	ldx	#8 ; default to device 8
	tay ; secondary address
	jsr	SETLFS
	jsr	OPEN
	bcs	.could_not_open

	ldx	#WRITEFILENO ; file number
	jsr	CHKOUT

	ldx	tmp_x
	inx
	inx
	inx
	inx
	+NEXT

loadbase
	lda	COMPILE_ADDR
	sta	load_binary_laddr_lo
	sta	COMPILE
	lda	COMPILE_ADDR + 1
	sta	load_binary_laddr_hi
	sta	COMPILE + 1

	inc	LOAD_DEPTH

	lda	#<basename
	tax
	ldy	#>basename
	lda	#basename_end - basename

	jmp	load_binary

.could_not_open
	inc	$d020
	jmp	.could_not_open

basename
!text	"base"
basename_end

; LATEST - points to the most recently defined dictionary word.
	!word	LINK
	!set	LINK = * - 2
	!byte 6
	!text	"latest"
LATEST
	+VAR_CODE	_LATEST
_LATEST
	!word	LINK

; PUT NO CONTENT AFTER LATEST!!!! It will be overwritten!!!!
