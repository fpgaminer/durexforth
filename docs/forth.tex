\chapter{Forth Words}

\section{Stack Manipulation}

\begin{description}


\item[drop ( a -- )]

Drop top of stack.

\item[dup ( a -- a a )]

Duplicate top of stack.

\item[swap ( a b -- b a )]

Swap top stack elements.

\item[over ( a b -- a b a )]

Make a copy of the second item and push it on top.

\item[rot ( a b c -- b c a )]

Rotate the third item to the top.

\item[-rot ( a b c -- c a b )]

rot rot

\item[2drop ( a b -- )]

Drop two topmost stack elements.

\item[2dup ( a b -- a b a b )]

Duplicate two topmost stack elements.

\item[2swap ( a b c d -- c d a b )]

Swap topmost double stack elements.

\item[?dup ( a -- a a? )]

Dup a if a differs from 0.

\item[nip ( a b -- b )]

swap drop

\item[tuck ( a b -- b a b )]

dup -rot

\item[pick ( $x_u$ ... $x_1$ $x_0$ $u$ -- $x_u$ ... $x_1$ $x_0$ $x_u$ )]

Pick from stack element with depth u to top of stack.

\item[$>$r ( a -- )]

Move value from top of parameter stack to top of return stack. 

\item[r$>$ ( a -- )]

Move value from top of return stack to top of parameter stack. 

\item[r@ ( -- a )]

Fetch value of top of return stack (without lifting it).

\item[rdrop ( -- )]

Drop value on top of return stack.

\end{description}

\section{Utility}

\begin{description}
\item[. ( a -- )]

Print top word of stack in hex.

\item[c. ( a -- )]

Print top byte of stack in hex.

\item[emit ( a -- )]

Print top byte of stack as a PETSCII character.

\end{description}

\section{Mathematics}

\begin{description}

\item[1+ ( a -- b )]

Increase top of stack value by 1.

\item[1- ( a -- b )]

Decrease top of stack value by 1.

\item[2+ ( a -- b )]

Increase top of stack value by 2.

\item[+! ( n a -- )]

Add n to memory address a.

\item[+ ( a b -- c )]

Add a and b.

\item[- ( a b -- c )]

Subtract b from a.

\item[* ( a b -- c )]

Multiply a with b.

\item[/mod ( a b -- r q )]

Divide a with b. r = rest, q = quotient.

\item[/ ( a b -- q )]

Divide a with b.

\item[mod ( a b -- r )]

Rest of a divided by b.

\item[= ( a b -- c )]

Is a equal to b?

\item[$<>$ ( a b -- c )]

Does a differ from b?

\item[$<$ ( a b -- c )]

Is a less than b?

\item[$>$ ( a b -- c )]

Is a greater than b?

\item[$>=$ ( a b -- c)]

Is a greater than or equal to b?

\item[$<=$ ( a b -- c)]

Is a less than or equal to b?

\item[$0>$ ( a b -- c)]

Is a greater than zero?

\end{description}

\section{Logic}

\begin{description}
\item[and ( a b -- c )]

Binary and.

\item[or ( a b -- c )]

Binary or.

\item[xor ( a b -- c )]

Binary exclusive or.

\item[not ( a -- b )]

Flip all bits of a.

\end{description}

\section{Memory}

\begin{description}
\item[! ( value address -- )]

Store 16-bit value at address.

\item[@ ( address -- value )]

Fetch 16-bit value from address.

\item[c! ( value address -- )]

Store 8-bit value at address.

\item[c@ ( address -- value )]

Fetch 8-bit value from address.

\item[fill ( byte addr len -- )]

Fill range [addr, len + addr) with byte value.

\item[cmove ( len dst src -- )]

Forward copy len bytes from src to dst.

\item[cmove$>$ ( len dst src -- )]

Backward copy len bytes from src to dst.

\item[forget word]

\texttt{forget foo} forgets Forth word \texttt{foo} and everything defined after it.

\end{description}
\section{Compiling}

\begin{description}
\item[:]

Start compiling Forth word.

\item[;]

End compiling.

\item[\#]

Comment to end of line.

\item[(]

Start multi-line comment.

\item[)]

End multi-line comment.

\end{description}

\section{Variables}

\subsection{Values}

Values are fast to read, slow to write.

\begin{description}
\item[: foo 1 ;] Define value foo.
\item[1 value foo] Equivalent to the above.
\item[foo] Fetch value of foo.
\item[0 to foo] Set foo to 0.
\end{description}

\subsection{Variables}

Variables are faster to write to than values.

\begin{description}
\item[var foo] Define variable foo.
\item[foo @] Fetch value of foo.
\item[1 foo !] Set value of foo to 1.
\end{description}

\subsection{Arrays}

\begin{description}
\item[10 allot value foo] Allocate 10 bytes to array foo.
\item[1 foo 2 + !] Store 1 in position 2 of foo.
\item[foo dump] See contents of foo.
\end{description}


\section{Control Flow}

Control functions only work in compile mode, not in interpreter.

\begin{description}
\item[if ... then]

condition IF true-part THEN rest

\item[if ... else ... then]

condition IF true-part ELSE false-part THEN rest

\item[begin ... again]

Infinite loop.

\item[begin ... until]

BEGIN loop-part condition UNTIL.

Loop until condition is true.

\item[begin ... while ... repeat]

BEGIN condition WHILE loop-part REPEAT.

Repeat loop-part while condition is true.

\item[exit]

Exit function.

\item[recurse] Jump to the start of the word being compiled.

\end{description}

\section{Keyboard Input}

\begin{description}
\item[key ( -- n )]

Read a character from input. Buffered/unbuffered reading is controlled by the \texttt{linebuf} variable.

\item[linebuf]

This variable switches between buffered/unbuffered input. Disable input buffering with \texttt{0 linebuf c!}, enable with \texttt{1 linebuf c!}.

\end{description}

\section{Editing}

\begin{description}
\item[edit ( s -- )]

Open editor. Try \texttt{s" foo" edit}.

\item[fg]

Re-open editor to pick up where it left.

\end{description}

\section{Strings}

\begin{description}
\item[."]

Print a string. E.g. \texttt{." foo"}

\item[s"]

Define a string and put it on the stack. E.g. \texttt{s" foo"}

\end{description}

\section{Debugging}

\begin{description}
\item[.s]

See stack contents.

\item[words]

List all defined words.

\item[sizes]

List sizes of all defined words.

\item[dump ( n -- )]

Memory dump starting at address n.

\item[n]

Continue memory dump where last one stopped.

\item[see word]

Decompile Forth word and print to screen. Try \texttt{see see}.

\end{description}



\section{System State}

\begin{description}

\item[latest (variable)] Position of latest defined word.

\item[here (variable)] Write position of the Forth compiler (usually first unused byte of memory). Many C64 assemblers refer to this as program counter or \texttt{*}.

\item[blink ( status -- )] Disable/enable cursor blink. (0 = off, 1 = on)

\end{description}



\section{``Missing'' Words}

The following words might be expected in a "normal" Forth, but are not included in durexForth for the sake of keeping it lean:

\begin{itemize}
\item do ... loop, i, j
\item */, */mod
\item abs
\end{itemize}

Also, I do not have time to describe every word defined. Please refer to a Forth reference manual and/or the source.
