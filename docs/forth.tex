\chapter{Forth Words}

\section{Basic Stack Manipulation}

\subsection{drop ( a -- )}

Drop top of stack.

\subsection{dup ( a -- a a )}

Duplicate top of stack.

\subsection{swap ( a b -- b a )}

Swap top stack elements.

\subsection{over ( a b -- a b a )}

Swap top stack elements.

\subsection{rot ( a b c -- c a b )}

Rotate top three stack elements from bottom to top.

\subsection{-rot ( a b c -- b c a )}

Rotate top three stack elements from top to bottom.

\subsection{2drop ( a b -- )}

Drop two topmost stack elements.

\subsection{2dup ( a b -- a b a b )}

Duplicate two topmost stack elements.

\subsection{2swap ( a b c d -- c d a b )}

Swap topmost double stack elements.

\subsection{?dup ( a -- a a? )}

Dup a if a differs from 0.


\section{Utility}

\subsection{. ( a -- )}

Print top of stack.


\section{Mathematics}

\subsection{hex}

Use hexadecimal base for input.

\subsection{dec}

Use decimal base for input.

\subsection{1+ ( a -- b )}

Increase top of stack value by 1.

\subsection{1- ( a -- b )}

Decrease top of stack value by 1.

\subsection{2+ ( a -- b )}

Increase top of stack value by 2.

\subsection{+ ( a b -- c )}

Add a and b.

\subsection{- ( a b -- c )}

Subtract b from a.

\subsection{* ( a b -- c )}

Multiply a with b.

\subsection{/mod ( a b -- r q )}

Divide a with b. r = rest, q = quotient.

\subsection{/ ( a b -- q )}

Divide a with b.

\subsection{mod ( a b -- r )}

Rest of a divided by b.

\subsection{= ( a b -- c )}

Is a equal to b?

\subsection{$<>$ ( a b -- c )}

Does a differ from b?

\subsection{$<$ ( a b -- c )}

Is a less than b?

\subsection{$>$ ( a b -- c )}

Is a greater than b?

\subsection{$>=$ ( a b -- c)}

Is a greater than or equal to b?

\subsection{$<=$ ( a b -- c)}

Is a less than or equal to b?

\subsection{$0>$ ( a b -- c)}

Is a greater than zero?


\section{Logic}

\subsection{and ( a b -- c )}

Binary and.

\subsection{or ( a b -- c )}

Binary or.

\subsection{xor ( a b -- c )}

Binary exclusive or.

\subsection{not ( a -- b )}

Flip all bits of a.


\section{Memory}

\subsection{! ( value address -- )}

Store 16-bit value at address.

\subsection{@ ( address -- value )}

Fetch 16-bit value from address.

\subsection{c! ( value address -- )}

Store 8-bit value at address.

\subsection{c@ ( address -- value )}

Fetch 8-bit value from address.

\subsection{fill ( byte addr len -- )}

Fill range [addr, len + addr) with byte value.

\subsection{cmove ( len dst src -- )}

Forward copy len bytes from src to dst.

\subsection{cmove$>$ ( len dst src -- )}

Backward copy len bytes from src to dst.


\section{Compiling}

\subsection{:}

Start compiling Forth word.

\subsection{;}

End compiling.

\subsection{\#}

Comment to end of line.

\subsection{(}

Start multi-line comment.

\subsection{)}

End multi-line comment.


\section{Control Flow}

\subsection{begin ... again}

Infinite loop.

\subsection{begin ... f until}

Loop until f is true.

\subsection{begin ... f while ... repeat}

Repeat while f is true.

\subsection{exit}

Exit function.


\section{"Missing" Words}

The following words might be expected in a "normal" Forth, but are not included in durexForth for the sake of keeping it lean:

\begin{itemize}
\item do ... loop, i, j
\item */, */mod
\item abs
\end{itemize}
