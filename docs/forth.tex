\chapter{Forth Words}

\section{Stack Manipulation}

\begin{description}


\item[drop ( a -- )]

Drop top of stack.

\item[dup ( a -- a a )]

Duplicate top of stack.

\item[swap ( a b -- b a )]

Swap top stack elements.

\item[over ( a b -- a b a )]

Make a copy of the second item and push it on top.

\item[rot ( a b c -- b c a )]

Rotate the third item to the top.

\item[-rot ( a b c -- c a b )]

rot rot

\item[2drop ( a b -- )]

Drop two topmost stack elements.

\item[2dup ( a b -- a b a b )]

Duplicate two topmost stack elements.

\item[2swap ( a b c d -- c d a b )]

Swap topmost double stack elements.

\item[?dup ( a -- a a? )]

Dup a if a differs from 0.

\item[nip ( a b -- b )]

swap drop

\item[tuck ( a b -- b a b )]

dup -rot

\item[pick ( $x_u$ ... $x_1$ $x_0$ $u$ -- $x_u$ ... $x_1$ $x_0$ $x_u$ )]

Pick from stack element with depth u to top of stack.

\item[$>$r ( a -- )]

Move value from top of parameter stack to top of return stack. 

\item[r$>$ ( a -- )]

Move value from top of return stack to top of parameter stack. 

\item[r@ ( -- a )]

Fetch value of top of return stack (without lifting it).

\item[rdrop ( -- )]

Drop value on top of return stack.

\end{description}

\section{Utility}

\begin{description}
\item[. ( a -- )] Print top value of stack.
\item[c. ( a -- )] Print top byte of stack.
\item[.s] See stack contents.
\item[emit ( a -- )] Print top byte of stack as a PETSCII character.
\item[\#] Comment to end of line.
\item[(] Start multi-line comment.
\item[)] End multi-line comment.
\end{description}


\section{Mathematics}

\begin{description}

\item[1+ ( a -- b )]

Increase top of stack value by 1.

\item[1- ( a -- b )]

Decrease top of stack value by 1.

\item[2+ ( a -- b )]

Increase top of stack value by 2.

\item[+! ( n a -- )]

Add n to memory address a.

\item[+ ( a b -- c )]

Add a and b.

\item[- ( a b -- c )]

Subtract b from a.

\item[* ( a b -- c )]

Multiply a with b.

\item[/mod ( a b -- r q )]

Divide a with b. r = rest, q = quotient.

\item[/ ( a b -- q )]

Divide a with b.

\item[mod ( a b -- r )]

Rest of a divided by b.

\item[= ( a b -- c )]

Is a equal to b?

\item[$<>$ ( a b -- c )]

Does a differ from b?

\item[$<$ ( a b -- c )]

Is a less than b?

\item[$>$ ( a b -- c )]

Is a greater than b?

\item[$>=$ ( a b -- c)]

Is a greater than or equal to b?

\item[$<=$ ( a b -- c)]

Is a less than or equal to b?

\item[$0>$ ( a b -- c)]

Is a greater than zero?

\end{description}

\section{Logic}

\begin{description}
\item[and ( a b -- c )]

Binary and.

\item[or ( a b -- c )]

Binary or.

\item[xor ( a b -- c )]

Binary exclusive or.

\item[not ( a -- b )]

Flip all bits of a.

\end{description}

\section{Memory}

\begin{description}
\item[! ( value address -- )]

Store 16-bit value at address.

\item[@ ( address -- value )]

Fetch 16-bit value from address.

\item[c! ( value address -- )]

Store 8-bit value at address.

\item[c@ ( address -- value )]

Fetch 8-bit value from address.

\item[fill ( byte addr len -- )]

Fill range [addr, len + addr) with byte value.

\item[cmove ( len dst src -- )]

Forward copy len bytes from src to dst.

\item[cmove$>$ ( len dst src -- )]

Backward copy len bytes from src to dst.

\item[forget word]

\texttt{forget foo} forgets Forth word \texttt{foo} and everything defined after it.

\end{description}
\section{Compiling}

\begin{description}
\item[:] Start compiling Forth word at \texttt{here} position.
\item[;] End compiling.
\item[, ( n -- )] Write word on stack to \texttt{here} position and increase \texttt{here} by 2.
\item[c, ( n -- )] Write byte on stack to \texttt{here} position and increase \texttt{here} by 1.
\item[literal ( n -- )] Compile a value from the stack as a literal value.
\item[[ ( -- )] Leave compile mode. Execute the following words immediately instead of compiling them.
\item[{]} ( -- )] Return to compile mode.
\item[immed] Mark the word being compiled as immediate (i.e. inside colon definitions, it will be executed immediately instead of compiled).
\item[[compile{]} xxx] Compile the immediate word \texttt{xxx} instead of executing it.
\item[{[']} xxx] Compile the execution token of word \texttt{xxx} as a literal value.
\item[create xxx] Create a dictionary header with name \texttt{xxx}. 
\end{description}

\section{Variables}

\subsection{Values}

Values are fast to read, slow to write.

\begin{description}
\item[: foo 1 ;] Define value foo.
\item[1 value foo] Equivalent to the above.
\item[foo] Fetch value of foo.
\item[0 to foo] Set foo to 0.
\end{description}

\subsection{Variables}

Variables are faster to write to than values.

\begin{description}
\item[var foo] Define variable foo.
\item[foo @] Fetch value of foo.
\item[1 foo !] Set value of foo to 1.
\end{description}

\subsection{Arrays}

\begin{description}
\item[10 allot value foo] Allocate 10 bytes to array foo.
\item[1 foo 2 + !] Store 1 in position 2 of foo.
\item[foo dump] See contents of foo.
\end{description}

It is also possible to build arrays using \texttt{create}. The initialization is easier, but access is slightly different:

\begin{verbatim}
create 2powtable 0 c, 1 c, 2 c, 4 c, 8 c,
	10 c, 20 c, 40 c, 80 c,
: 2pow ( n -- 2pown ) ['] 2powtable + c@ ;
\end{verbatim}


\section{Control Flow}

Control functions only work in compile mode, not in interpreter.

\begin{description}
\item[if ... then]

condition IF true-part THEN rest

\item[if ... else ... then]

condition IF true-part ELSE false-part THEN rest

\item[begin ... again]

Infinite loop.

\item[begin ... until]

BEGIN loop-part condition UNTIL.

Loop until condition is true.

\item[begin ... while ... repeat]

BEGIN condition WHILE loop-part REPEAT.

Repeat loop-part while condition is true.

\item[exit]

Exit function.

\item[recurse] Jump to the start of the word being compiled.

\end{description}

\section{Keyboard Input}

\begin{description}
\item[key ( -- n )]

Read a character from input. Buffered/unbuffered reading is controlled by the \texttt{linebuf} variable.

\item[word ( -- addr )] Read a word from input and put it on the stack.

\item[linebuf]

This variable switches between buffered/unbuffered input. Disable input buffering with \texttt{0 linebuf c!}, enable with \texttt{1 linebuf c!}.

\end{description}

\section{Editing}

\begin{description}
\item[edit ( s -- )]

Open editor. Try \texttt{s" foo" edit}.

\item[fg]

Re-open editor to pick up where it left.

\end{description}

\section{Strings}

\begin{description}
\item[."]

Print a string. E.g. \texttt{." foo"}

\item[s"] Run time: ( -- strptr strlen ) Compile time: ( -- str )

Define a string and put it on the stack. E.g. \texttt{s" foo"}. 

In run time, it puts the string length and a text pointer on the stack. In compile time (inside a colon definition), it puts a pointer to a Pascal-string on the stack.

\end{description}


\section{Vectored Execution}

\begin{description}
\item[' xxx ( -- addr )] Find execution token of word \texttt{xxx}.
\item[exec ( xt -- )] Execute the execution token on stack.
\item[$>$cfa ( addr -- xt )] Get execution token (a.k.a. code field adress) of word at adress \texttt{addr}.
\item[loc xxx ( -- addr )] Get adress of word xxx.

Example: \texttt{f = loc f >cfa exec}
\end{description}


\section{Debugging}

\begin{description}
\item[words] List all defined words.
\item[sizes] List sizes of all defined words.
\item[dump ( n -- )] Memory dump starting at address n.
\item[n] Continue memory dump where last one stopped.
\item[see word] Decompile Forth word and print to screen. Try \texttt{see see}.
\end{description}


\section{System State}

\begin{description}

\item[latest (variable)] Position of latest defined word.

\item[here (variable)] Write position of the Forth compiler (usually first unused byte of memory). Many C64 assemblers refer to this as program counter or \texttt{*}.

\item[sp@ ( -- addr )] Address of stack top before \texttt{sp@} is executed.
\item[sp0 (variable)] Address of stack bottom.
\item[blink ( status -- )] Disable/enable cursor blink. (0 = off, 1 = on)

\end{description}


\section{Disk I/O}

\begin{description}
\item[loadb ( filenameptr filenamelength dst -- )] Load binary block to dst.
\item[saveb ( start end filenameptr filenamelength -- )] Save binary block.
\end{description}


\section{Kernel Calls}

Safe kernel calls may be done from Forth words using \texttt{jsr-wrap} ( addr -- ). The helper variables \texttt{ar}, \texttt{xr} and \texttt{yr} can be used to set arguments and get results through the a, x and y registers.

Example: \texttt{30 ar ! ffd2 jsr-wrap} prints \texttt{0} on screen.

\section{``Missing'' Words}

The following words might be expected in a "normal" Forth, but are not included in durexForth for the sake of keeping it lean:

\begin{itemize}
\item do ... loop, i, j
\item */, */mod
\item abs
\end{itemize}

Also, I do not have time to describe every word defined. Please refer to a Forth reference manual and/or the source.
