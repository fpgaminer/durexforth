hex
: return d ;
: clrscr e544 jsr ;

: bufstart 4000 ;

var eof ( ram eof )

var homepos ( position at screen home )
var currlinestart
var currxpos

( cursor screen pos )
var curx 
var cury
var curx-prev
var cury-prev

: max ( a b - c )
	2dup ( a b a b )
	< if swap then
	drop
;

: min ( a b - c )
	2dup ( a b a b )
	> if swap then
	drop
;

: editpos
	currlinestart @ currxpos @ +
;

: linewidth
	0
	currlinestart @ ( count addr )
	begin
		dup c@ return = if
			drop 
			dup 0= if
				1+ ( never return 0, min is 1 )
			then
			exit
		then

		1+
		swap 1+ swap
	again
;

: update-cursor
	cury-prev @ 28 *
	curx-prev @ +
	400 + ( addr )
	dup @ 7f and
	swap c!

	cury @ 28 *
	curx @ linewidth 1- min +
	400 + ( addr )
	dup @ 80 or
	swap c!

	curx @ linewidth 1- min curx-prev c!
	cury @ cury-prev c!
;

: do-load
	load
	bufstart eof !

	begin
		read ( char )

		dup ( char char )

		eof @ ( char char *eof )
		c!

		0= if exit then

		1 eof +!
	again
;

: go-to-file-start
	0 curx !
	0 cury !
	bufstart homepos !
	0 currxpos !
	bufstart currlinestart !
;

: print-line ( addr -- newaddr )
	begin
		dup c@ ( addr char )
		dup return = ( addr char bool )
		if
			drop
			1+
			exit
		else
			emit
			1+
		then
	again
;	

: show-page
	clrscr
	0 >r
	homepos @
	begin
		print-line
		dup eof @ <
		r> 1+ dup >r 18 < and
	while
		cr
	repeat
	r>
	2drop
	
	update-cursor
;

: init
	( disable input buffering )
	0 linebuf c! 

	( colors )
	a d021 c!
	2 d020 c!
	1 286 c!

	0 curx-prev !
	0 cury-prev !

	go-to-file-start
;

: cur-down
	currlinestart @ ( addr )
	dup c@ return <> if
		begin
			dup eof @ = if
				drop
				exit
			then
			1+ ( addr )
			dup c@ ( addr char )
			return =
		until
	then
	1+ ( newlinestart )

	dup c@ 0= if ( eof )
		drop
		exit
	then

	currlinestart !
	1 cury +!
;

: cur-up
	currlinestart @ bufstart = if
		( already at top )
		exit
	then

	currlinestart @ ( addr )
	1- ( skip first return plz )
	begin
		1- ( addr )
		dup c@ ( addr char )
		return = ( addr bool )

		over ( addr bool addr )
		bufstart < ( addr bool bool )
		or ( addr bool )
	until
	( addr )

	1+
	bufstart max
	currlinestart !
	ffff cury +!
;

: cur-left
	currxpos @
	?dup 0= if
		exit
	then

	ffff currxpos +!
	ffff curx +!
;

: is-eof-or-return
	dup 0= swap return = or
;

: cur-right
	editpos c@ is-eof-or-return
	editpos 1+ c@ is-eof-or-return
	or if
		exit
	then
	1 currxpos +!
	1 curx +!
;

: main-loop
	begin
		key

		case

		[ char h ] literal of cur-left endof
		[ char j ] literal of cur-down endof
		[ char k ] literal of cur-up endof
		[ char l ] literal of cur-right endof

			( default )
		endcase

		update-cursor
	again
;

: edit
	0 blink

	do-load
	
	init

	show-page

	main-loop
;

s" debug" edit

