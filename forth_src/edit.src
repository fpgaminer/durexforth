hex
: return d ;
: clrscr e544 jsr ;

: bufstart 4000 ;

var eof ( ram eof )

var homepos ( position at screen home )
var editpos
var currlinestart

( cursor screen pos )
var curx 
var cury
var curx-prev
var cury-prev

( logical x pos... where the cursor "wants" to be 
when scrolling vertically )
var rowx

: update-cursor
	cury-prev @ 28 *
	curx-prev @ +
	400 + ( addr )
	dup @ 7f and
	swap c!

	cury @ 28 *
	curx @ +
	400 + ( addr )
	dup @ 80 or
	swap c!

	curx c@ curx-prev c!
	cury c@ cury-prev c!
;

: do-load
	load
	bufstart eof !

	begin
		read ( char )

		?dup if
			eof @ dup ( char *eof *eof )
			rot ( *eof char *eof )
			c! ( *eof )
			1+ eof !
		else
			drop
			exit
		then
	again
;

: go-to-file-start
	0 curx !
	0 cury !
	0 rowx !
	bufstart homepos !
	bufstart editpos !
	bufstart currlinestart !
;

: print-line ( addr -- newaddr )
	begin
		dup c@ ( addr char )
		dup return = ( addr char bool )
		if
			drop
			1+
			exit
		else
			emit
			1+
		then
	again
;	

: show-page
	clrscr
	homepos @
	begin
		print-line
		dup eof @ <
	while
		cr
	repeat
	drop
	
	update-cursor
;

: @1+! dup @ 1+ swap !  ;
: @1-! dup @ 1- swap !  ;

: init
	( disable input buffering )
	0 linebuf c! 

	( colors )
	a d021 c!
	2 d020 c!
	1 286 c!

	0 curx-prev !
	0 cury-prev !

	go-to-file-start
;

: cur-down
	currlinestart @
	begin
		dup eof @ = if
			exit
		then
		1+ ( addr )
		dup c@ ( addr char )
		return =
	until
	1+ ( newlinestart )
	dup currlinestart @ - ( newlinestart diff )
	28 + 28 / ( newlinestart diff/40 )
	cury @ + cury !
	currlinestart !
;

: cur-up
	bufstart currlinestart @ <> if
		cury @1-!
	then
;

: cur-left
	curx @1-!
;

: cur-right
	curx @1+!
;

: main-loop
	begin
		key

		case

		[ char h ] literal of cur-left endof
		[ char j ] literal of cur-down endof
		[ char k ] literal of cur-up endof
		[ char l ] literal of cur-right endof

			( default )
		endcase

		update-cursor
	again
;

: edit
	0 blink

	do-load
	
	init

	show-page

	main-loop
;

s" test" edit

