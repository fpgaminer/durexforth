hex
: RETURN d ;
: clrscr bl 400 3e8 fill ;

: bufstart 4000 ;

var eof ( ram eof )

var homepos ( position at screen home )
var curlinestart

( cursor screen pos )
var curx 
var cury
0 value need-refresh
0 value need-refresh-line
0 value insert-active

10 allot dup 
value filename-len
1+ value filename

: max ( a b - c )
	2dup ( a b a b )
	< if swap then
	drop
;

: min ( a b - c )
	2dup ( a b a b )
	> if swap then
	drop
;

: editpos
	curlinestart @ curx @ +
;

: linelen
	0
	curlinestart @ ( count addr )
	begin
		dup c@ RETURN = if
			drop 
			exit
		then

		1+
		swap 1+ swap
	again
;

: cursor-scr-pos
	cury @ 28 *
	curx @ linelen min +
	400 + ( addr )
;

: hide-cursor
	cursor-scr-pos
	dup @ 7f and
	swap c!
;

: show-cursor
	insert-active 0= if
		curx @ linelen 1- min curx c!
	then

	cursor-scr-pos
	dup @ 80 or
	swap c!
;

: do-load
	load
	bufstart eof !

	begin
		read ( char )

		dup ( char char )

		eof @ ( char char *eof )
		c!

		0>
	while

		eof 1+!
	repeat

	bufstart 1+ eof @ = if
		# empty file?
		eof 1+!
		RETURN 4000 c!
		RETURN 4001 c!
		0 4002 c!
	then
;

: go-to-file-start
	0 curx !
	0 cury !
	bufstart homepos !
	bufstart curlinestart !
;

: show-page
	clrscr
	0 0 setcur
	homepos @
	begin
		dup c@ dup emit
		swap 1+ swap
		0=
		d6 c@ 18 = or
	until
	drop
;

: clear-status ( -- )
	bl 7c0 18 fill
;

: set-status ( c -- )
	clear-status
	7c0 c!
;

: init
	0 blink

	( disable input buffering )
	0 linebuf c! 

	clear-status
;

: push-colors
	d020 c@
	d021 c@
	286 c@

	a d021 c!
	2 d020 c!
	1 286 c!
	1 d800 400 fill
;

: cleanup
	1 linebuf c! # enable buffering

	1 blink
	286 c! # cursor col
	d021 c!
	d020 c!
	93 emit # clrscr
;

: adjust-home
	begin
		cury @ 8000 and
	while
		1 to need-refresh

		homepos 1-! ( skip first cr )
		begin
			homepos 1-!
			homepos @ c@ RETURN =
			homepos @ bufstart 1- = or
		until
		homepos 1+!
		cury 1+! ( cur down )
	repeat

	begin
		cury @ 17 >
	while
		1 to need-refresh

		homepos @ c@ RETURN <> if
			begin
				homepos 1+!
				homepos @ c@ RETURN =
			until
		then
		homepos 1+!
		cury 1-! ( cur up )
	repeat
;

: fit-curx-in-linelen
	linelen curx @ min curx !
;

: cur-down
	curlinestart @ ( addr )
	dup c@ RETURN <> if
		begin
			dup eof @ = if
				drop
				exit
			then
			1+ ( addr )
			dup c@ ( addr char )
			RETURN =
		until
	then
	1+ ( newlinestart )

	dup eof @ >= if ( eof )
		drop
		exit
	then

	curlinestart !
	cury 1+!

	fit-curx-in-linelen

	adjust-home
;

: cur-up
	curlinestart @ bufstart = if
		exit ( already at top )
	then

	curlinestart @ ( addr )
	1- ( skip first RETURN plz )
	begin
		1- ( addr )
		dup c@ ( addr char )
		RETURN = ( addr RETURN? )

		over ( addr RETURN? addr )
		bufstart < ( addr RETURN? sof? )
		or ( addr bool )
	until
	( addr )

	1+
	bufstart max
	curlinestart !
	cury 1-!

	fit-curx-in-linelen

	adjust-home
;

: cur-left
	curx @
	0= if exit then

	curx 1-!
;

: is-eof-or-RETURN
	dup 0= swap RETURN = or
;

: is-whitespace
	dup RETURN = swap bl = or
;

: cur-right
	editpos c@ is-eof-or-RETURN
	editpos 1+ c@ is-eof-or-RETURN
	or if
		exit
	then
	curx 1+!
;

: eol
	linelen 
	dup 0> if 1- then
	curx !
;

( left, or up + eol if we're at xpos 0 )
: rewind-cur
		curx @ 0= if
			bufstart editpos <> if
				cur-up
				eol
			then
		else
			cur-left
		then
;

: sol
	0 curx !
;

: word-back
	rewind-cur
	begin
		editpos bufstart =
		editpos 1- c@ is-whitespace
		editpos c@ is-whitespace not and
		or not
	while
		rewind-cur
	repeat
;

# right, or down + sol if we're at EOL. ret 1 if we cant advance
: advance-cur
	editpos
	curx @ linelen 1- = linelen 0= or if
		0 curx !
		cur-down
	else
		cur-right
	then
	editpos =
;

: word-fwd
	advance-cur if exit then
	begin
		editpos 1- c@ is-whitespace
		editpos c@ is-whitespace not and
		not
	while
		advance-cur if exit then
	repeat
;

: half-page-back
	c begin cur-up 1- dup 0= until drop
;

: half-page-fwd
	c begin cur-down 1- dup 0= until drop
;

: find-prev-RETURN ( addr -- new-addr )
	begin
		1-
		dup bufstart <=
		over c@ RETURN =
		or
	until
	bufstart max
;

: goto-eof ( can be much optimized... )
	begin
		editpos
		half-page-fwd
		editpos =
	until

	1 to need-refresh
;

: goto-start ( can be much optimized... )
	0 curx !
	0 cury !
	bufstart dup homepos ! curlinestart !
	1 to need-refresh
;

: insert-start
	1 to insert-active
	[ char i ] literal set-status
;

: force-cur-right
	linelen 0> if
		curx 1+!
	then
;

: append-start
	force-cur-right
	insert-start
;

: insert-stop
	curx @ if
		curx 1-!
	then
	0 to insert-active
	clear-status
;

: show-location
	dup ( loc sol )
	begin
		dup c@ RETURN = if
			1+
			dup ( loc sol sol )
			rot ( sol loc sol )
			- curx !
			0 cury !
			dup homepos !
			curlinestart !
			exit
		then
		1-
	again
;

: refresh-line
	curx @
	sol
	0 cury @ setcur
	27 linelen - ( spaces )
	linelen ( spaces chars )
	begin
		?dup 0>
	while
		editpos @ emit
		curx 1+!
		1-
	repeat
	begin
		?dup 0>
	while
		bl emit
		1-
	repeat
	curx !
	curx @ cury @ setcur
;

: replace-char
	key editpos c!
	1 to need-refresh-line
;

: del-char
	curx @ 0= if exit then
	curx 1-!
	editpos 1+
	editpos
	eof @ editpos - 1+
	eof 1-!
	cmove
	1 to need-refresh-line
;

: join-lines
	cury @
	curx @
	curlinestart @

	editpos
	cur-down
	editpos = if 2drop drop exit then
	sol
	editpos ( src )
	editpos 1- ( dst )
	eof @ editpos - 1+

	cmove

	eof 1-!

	curlinestart !
	curx !
	cury !

	1 to need-refresh
;

: insert-char
	eof @ editpos - ( u )
	dup 1- editpos + ( u src )
	over 1- editpos + 1+ ( u src dst )
	-rot ( src dst u )
	cmove>
	editpos c!
	curx 1+!
	eof 1+!
	0 eof @ c!
	1 to need-refresh-line
;

: LEFT 9d ;
: DOWN 11 ;
: UP 91 ;
: RIGHT 1d ;

: insert-handler
	dup
	case
	5f of insert-stop drop endof # leftarrow
	LEFT of cur-left drop endof
	DOWN of cur-down drop endof
	UP of cur-up drop endof
	RIGHT of cur-right drop endof
	14 of del-char drop endof # inst
	94 of curx 1+! del-char drop endof # del
	RETURN of insert-char cur-down sol endof
	insert-char
	endcase
;

: push-cursor
	curx @
	cury @
	curlinestart @
;

: pop-cursor
	curlinestart !
	cury !
	curx !
;

: del-word
	push-cursor
	editpos ( dst )
	word-fwd
	editpos ( dst src )
	2dup - >r ( store diff )
	eof @ editpos - 1+ ( dst src len )
	r> eof +! ( adjust eof with diff )
	rot ( len dst src )
	swap ( len src dst )
	-rot ( src dst len )
	cmove
	1 to need-refresh
	pop-cursor
;

28 allot value clipboard
var clipboard-count
0 clipboard-count !

# this can be much optimized by using cmove
: del-line
	0 clipboard-count !
	sol
	begin
		linelen 0>
	while
        # copy to clipboard
		editpos c@
		clipboard clipboard-count @ +
		c!
		clipboard-count 1+!

        # delete
		force-cur-right
		del-char
	repeat
	join-lines
	1 to need-refresh
;

: delete-handler
	[ char d ] literal set-status

	key

	case
	[ char w ] literal of del-word endof
	[ char d ] literal of del-line endof
	endcase

	clear-status
;

10 allot value search-buf

: are-equal ( len a1 a2 -- equal? )
	-rot ( a1 a2 len )
	>r ( a1 a2 )
	begin
		r@ ( a1 a2 len )
		0= if ( is len 0? )
			( matches! )
			2drop
			rdrop
			1
			exit
		then
		( a1 a2 )
		dup c@ ( a1 a2 c2 )
		-rot ( a2 c2 a1 )
		dup c@ ( a2 c2 a1 c1 )
		-rot ( a2 a1 c1 c2 )
		<> ( a2 a1 diff? )
		if
			( not equal!! )
			2drop ( )
			rdrop
			0
			exit
		then
		1+ ( a2 a1 )
		swap 1+ ( a1 a2 )
		r> 1- >r
	again
;

: do-find ( count -- addr )
	editpos ( count a1 )
	1+ ( count a1 )
	begin
		dup eof @ = if
			drop bufstart ( count a1 )
		then
		dup editpos = if
			( not found )
			2drop
			0
			exit
		then

		dup @ search-buf @ = if
			( first char matches... examine )
			2dup ( count a1 count a1 )
			search-buf ( count a1 count a1 search-buf )
			are-equal ( count a1 equal? )
			if
				( count a1 )
				swap drop ( a1 )
				exit
			then
		then
		1+
	again
;

18 allot value drivebuf

: do-backup
	# scratch old backup
	drivebuf
	dup [ char s ] literal swap c! 1+
	dup [ char : ] literal swap c! 1+
	dup [ char . ] literal swap c! 1+
	dup
	filename swap filename-len c@ cmove
	filename-len c@ +
	RETURN swap c!

	f drivebuf filename-len c@ 4 + openw
	closew

	# rename to new backup
	drivebuf
	dup [ char r ] literal swap c! 1+
	1+ # colon already in place...
	dup [ char . ] literal swap c! 1+
	filename-len c@ + # filename ok
	dup [ char = ] literal swap c! 1+
	dup
	filename swap filename-len c@ cmove
	filename-len c@ + # filename ok
	RETURN swap c!

	f drivebuf filename-len c@ 2 * 5 + openw
	closew
;

: write-file
	d020 c@

	do-backup

	# add ",P,W" to make it an output filename
	filename filename-len c@ +
	dup [ char , ] literal swap c! 1+
	dup [ char p ] literal swap c! 1+
	dup [ char , ] literal swap c! 1+
	[ char w ] literal swap c!

	2 filename filename-len c@ 4 + openw
	bufstart
	begin
		dup c@ dup d020 c! write
		1+
		dup eof @ =
	until
	closew
	drop
	d020 c!
;

: find-handler
	0 18 setcur
	clear-status
	[ char / ] literal emit
	0 ( count )
	begin
		key dup
		RETURN <> if
			( count key )
			dup emit
			over search-buf + ( count key dst )
			c! ( count )
			1+
			0
		else
			drop
			1
		then
	until
	do-find ( count )
	?dup if
		( found! )
		show-location
	then
;

: open-line
	sol RETURN insert-char sol
	insert-start
	1 to need-refresh
;

: paste-line
	open-line
	clipboard-count @
	0
	begin
		2dup <> 
	while
		clipboard over + @
		insert-char
		1+
	repeat
	2drop
	insert-stop
	sol
;

: change-word
	del-word 
	bl insert-char
	cur-left
	insert-start 
;

: force-cur-down
	editpos
	cur-down
	editpos = if
		eol 
		force-cur-right
		RETURN insert-char
		cur-down
	then
;

: main-handler ( 0 -- quit? )
	case

	[ char i ] literal of insert-start endof
	[ char a ] literal of append-start endof

	[ char / ] literal of find-handler endof
	[ char U ] literal of half-page-back endof
	[ char D ] literal of half-page-fwd endof
	[ char J ] literal of join-lines endof
	[ char G ] literal of goto-eof endof
	[ char $ ] literal of eol endof
	[ char 0 ] literal of sol endof
	[ char r ] literal of replace-char endof
	[ char o ] literal of force-cur-down open-line endof
	[ char O ] literal of open-line endof
	[ char p ] literal of force-cur-down paste-line endof
	[ char P ] literal of paste-line endof
	[ char x ] literal of curx 1+! del-char endof
	[ char X ] literal of del-char endof
	[ char b ] literal of word-back endof
	[ char w ] literal of word-fwd endof
	[ char Z ] literal of
		key
		case
		[ char Z ] literal of write-file ffff exit endof
		endcase
	endof
	[ char : ] literal of 
		[ char : ] literal set-status
		key 
		case
		[ char 0 ] literal of goto-start endof
		[ char w ] literal of write-file endof
		[ char q ] literal of ffff exit endof
		endcase
		clear-status
	endof

	[ char d ] literal of delete-handler endof
	[ char c ] literal of
		key
		[ char w ] literal = if change-word then
	endof

	( cursor )
	LEFT of cur-left endof
	DOWN of cur-down endof
	UP of cur-up endof
	RIGHT of cur-right endof
	88 of bufstart compile ! ffff exit endof # f7
	[ char h ] literal of cur-left endof
	[ char j ] literal of cur-down endof
	[ char k ] literal of cur-up endof
	[ char l ] literal of cur-right endof

	endcase
	0
;

: main-loop
	begin
		0 to need-refresh
		0 to need-refresh-line

		dsp@ # stack check...

		show-cursor
		key
		hide-cursor

		insert-active if
			insert-handler
		else
			main-handler if 
				drop
				exit
			then
		then

		need-refresh if
			show-page
		else
			need-refresh-line if
				refresh-line
			then
		then

		2+ dsp@ <> if begin d020 1+! again then # warn if stack changed
	again
;

: edit
	init
	go-to-file-start

	# store away filename
	2dup ( str len str len )	
	filename-len c!
	filename f cmove

	do-load

	push-colors

	show-page

	main-loop

	cleanup
;

: fg # bring back editor
	init
	push-colors
	show-page
	main-loop
	cleanup
;

(
do-backup
s" debug" edit
s" test" edit
)

