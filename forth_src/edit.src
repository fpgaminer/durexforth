hex
: return d ;
: clrscr bl 400 3c0 fill ;

: bufstart 4000 ;

var eof ( ram eof )

var homepos ( position at screen home )
var currlinestart

( cursor screen pos )
var curx 
var cury
0 value need-refresh
0 value insert-active

: max ( a b - c )
	2dup ( a b a b )
	< if swap then
	drop
;

: min ( a b - c )
	2dup ( a b a b )
	> if swap then
	drop
;

: editpos
	currlinestart @ curx @ +
;

: linelen
	0
	currlinestart @ ( count addr )
	begin
		dup c@ return = if
			drop 
			dup 0= if
				1+ ( never return 0, min is 1 )
			then
			exit
		then

		1+
		swap 1+ swap
	again
;

: cursor-scr-pos
	cury @ 28 *
	curx @ linelen 1- min +
	400 + ( addr )
;

: hide-cursor
	cursor-scr-pos
	dup @ 7f and
	swap c!
;

: show-cursor
	curx @ linelen 1- min curx c!

	cursor-scr-pos
	dup @ 80 or
	swap c!
;

: do-load
	load
	bufstart eof !

	begin
		read ( char )

		dup ( char char )

		eof @ ( char char *eof )
		c!

		0= if exit then

		1 eof +!
	again
;

: go-to-file-start
	0 curx !
	0 cury !
	bufstart homepos !
	bufstart currlinestart !
;

: show-page
	clrscr
	0 0 setcur
	homepos @
	begin
		dup c@ emit
		1+
		dup eof @ =
		d6 c@ 18 = or
	until
	drop
;

: set-status
	7c0 c!
;

: clear-status
	bl 7c0 18 fill
;

: init
	( disable input buffering )
	0 linebuf c! 

	( colors )
	a d021 c!
	2 d020 c!
	1 286 c!
	1 dba0 28 fill ( status white )

	go-to-file-start
	20 set-status
;

: adjust-home
	begin
		cury @ 8000 and
	while
		1 to need-refresh

		ffff homepos +! ( skip first cr )
		begin
			ffff homepos +!
			homepos @ c@ return =
			homepos @ bufstart 1- = or
		until
		1 homepos +!
		1 cury +! ( cur down )
	repeat

	begin
		cury @ 17 >
	while
		1 to need-refresh

		homepos @ c@ return <> if
			begin
				1 homepos +!
				homepos @ c@ return =
			until
		then
		1 homepos +!
		ffff cury +! ( cur up )
	repeat
;

: cur-down
	currlinestart @ ( addr )
	dup c@ return <> if
		begin
			dup eof @ = if
				drop
				exit
			then
			1+ ( addr )
			dup c@ ( addr char )
			return =
		until
	then
	1+ ( newlinestart )

	dup c@ 0= if ( eof )
		drop
		exit
	then

	currlinestart !
	1 cury +!

	adjust-home
;

: cur-up
	currlinestart @ bufstart = if
		exit ( already at top )
	then

	currlinestart @ ( addr )
	1- ( skip first return plz )
	begin
		1- ( addr )
		dup c@ ( addr char )
		return = ( addr bool )

		over ( addr bool addr )
		bufstart < ( addr bool bool )
		or ( addr bool )
	until
	( addr )

	1+
	bufstart max
	currlinestart !
	ffff cury +!

	linelen 1- curx @ min curx !

	adjust-home
;

: cur-left
	curx @
	?dup 0= if
		exit
	then

	ffff curx +!
;

: is-eof-or-return
	dup 0= swap return = or
;

: is-whitespace
	dup return = swap bl = or
;

: cur-right
	editpos c@ is-eof-or-return
	editpos 1+ c@ is-eof-or-return
	or if
		exit
	then
	1 curx +!
;

: eol
	linelen 1- curx !
;

( left, or up + eol if we're at xpos 0 )
: rewind-cur
		curx @ 0= if
			bufstart editpos <> if
				cur-up
				eol
			then
		else
			cur-left
		then
;

: sol
	0 curx !
;

: word-back
	rewind-cur
	begin
		editpos bufstart =
		editpos 1- c@ is-whitespace
		editpos c@ is-whitespace not and
		or not
	while
		rewind-cur
	repeat
;

( right, or down + sol if we're at xpos = linelen + 1 )
: advance-cur
	curx @ linelen 1- = if
		0 curx !
		cur-down
	else
		cur-right
	then
;

: word-fwd
	advance-cur
	begin
		editpos 1- c@ is-whitespace
		editpos c@ is-whitespace not and
		not
	while
		advance-cur
	repeat
;

: half-page-back
	c begin cur-up 1- dup 0= until drop
;

: half-page-fwd
	c begin cur-down 1- dup 0= until drop
;

: goto-eof ( can be much optimized... )
	0 curx !
	0 >r
	eof @ ( addr )
	begin
		1-
		dup c@ return = if
			r> 1+ >r
		then
		dup bufstart =
		r> dup >r 18 = or
	until

	r> 1- cury !
	homepos !

	eof @ 1-
	begin
		1-
		dup c@ return =
	until
	1+
	currlinestart !

	1 to need-refresh
;

: goto-start ( can be much optimized... )
	0 curx !
	0 cury !
	bufstart dup homepos ! currlinestart !
	1 to need-refresh
;

: insert-start
	1 to insert-active
	[ char i ] literal set-status
;

: insert-stop
	curx @ if
		ffff curx +!
	then
	0 to insert-active
	20 set-status
;

: del-char
	curx @ 0= if exit then
	ffff curx +!
	editpos 1+
	editpos
	eof @ editpos - 1+
	ffff eof +!
	cmove
	1 to need-refresh
;

: join-lines
	cury @
	curx @
	currlinestart @

	cur-down
	sol
	editpos ( src )
	editpos 1- ( dst )
	eof @ editpos - 1+

	cmove

	currlinestart !
	curx !
	cury !

	1 to need-refresh
;

: insert-char
	eof @ editpos - ( u )
	dup 1- editpos + ( u src )
	over 1- editpos + 1+ ( u src dst )
	-rot ( src dst u )
	cmove>
	editpos c!
	1 curx +!
	1 eof +!
	1 to need-refresh
;

: insert-handler
	dup 14 = if insert-stop drop else
	dup 94 = if del-char drop else
	dup return = if insert-char cur-down sol else
	insert-char
	then then then
;

: delete-handler
	[ char d ] literal set-status

	( we need to restore these afterwards... )
	curx @
	cury @
	currlinestart @

	key

	case
	[ char w ] literal of 
		( delete word )
		editpos ( dst )
		word-fwd
		editpos ( dst src )
		eof @ editpos - 1+ ( dst src len )
		rot ( len dst src )
		swap ( len src dst )
		-rot ( src dst len )
		cmove
		1 to need-refresh
	endof
	[ char d ] literal of 
		( delete line )
		sol editpos ( dst )
		eol editpos 2+ ( dst src )
		eof @ editpos - 1+ ( dst src len )
		rot ( len dst src )
		swap ( len src dst )
		-rot ( src dst len )
		cmove
		1 to need-refresh
	endof
	endcase

	currlinestart !
	cury !
	curx !

	bl set-status
;

10 allot value search-buf

: are-equal ( len a1 a2 -- equal? )
	-rot ( a1 a2 len )
	>r ( a1 a2 )
	begin
		r@ ( a1 a2 len )
		0= if ( is len 0? )
			( matches! )
			2drop
			rdrop
			1
			exit
		then
		( a1 a2 )
		dup c@ ( a1 a2 c2 )
		-rot ( a2 c2 a1 )
		dup c@ ( a2 c2 a1 c1 )
		-rot ( a2 a1 c1 c2 )
		<> ( a2 a1 diff? )
		if
			( not equal!! )
			2drop ( )
			rdrop
			0
			exit
		then
		1+ ( a2 a1 )
		swap 1+ ( a1 a2 )
		r> 1- >r
	again
;

: do-find ( count -- addr )
	editpos ( count a1 )
	1+ ( count a1 )
	begin
		dup eof @ = if
			drop bufstart ( count a1 )
		then
		dup editpos = if
			( not found )
			drop
			0
			exit
		then

		dup @ search-buf @ = if
			( first char matches... examine )
			2dup ( count a1 count a1 )
			search-buf ( count a1 count a1 search-buf )
			are-equal ( count a1 equal? )
			if
				( count a1 )
				swap drop ( a1 )
				exit
			then
		then
		1+
	again
;

: show-location
	dup ( loc sol )
	begin
		dup c@ return = if
			1+
			dup ( loc sol sol )
			rot ( sol loc sol )
			- curx !
			0 cury !
			dup homepos !
			currlinestart !
			1 to need-refresh
			exit
		then
		1-
	again
;

: find-handler
	0 18 setcur
	clear-status
	[ char / ] literal emit
	0 ( count )
	begin
		key dup
		return <> if
			( count key )
			dup emit
			over search-buf + ( count key dst )
			c! ( count )
			1+
			0
		else
			drop
			1
		then
	until
	do-find ( count )
	?dup if
		( found! )
		show-location
	then
;

: main-handler
	case

	[ char i ] literal of insert-start endof

	[ char / ] literal of find-handler endof
	[ char U ] literal of half-page-back endof
	[ char D ] literal of half-page-fwd endof
	[ char J ] literal of join-lines endof
	[ char G ] literal of goto-eof endof
	[ char $ ] literal of eol endof
	[ char 0 ] literal of sol endof
	[ char x ] literal of 1 curx +! del-char endof
	[ char X ] literal of del-char endof
	[ char b ] literal of word-back endof
	[ char w ] literal of word-fwd endof
	[ char : ] literal of 
		[ char : ] literal set-status
		key [ char 0 ] literal = if goto-start then
		bl set-status
	endof

	[ char d ] literal of delete-handler endof

	( cursor )
	9d of cur-left endof
	11 of cur-down endof
	91 of cur-up endof
	1d of cur-right endof
	[ char h ] literal of cur-left endof
	[ char j ] literal of cur-down endof
	[ char k ] literal of cur-up endof
	[ char l ] literal of cur-right endof

	endcase
;

: main-loop
	begin
		0 to need-refresh

		show-cursor
		key
		hide-cursor

		insert-active if
			insert-handler
		else
			main-handler
		then

		need-refresh if
			show-page
		then
	again
;

: edit
	0 blink

	do-load
	
	init

	show-page

	main-loop
;

s" debug" edit

