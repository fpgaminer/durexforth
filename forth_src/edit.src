hex
: return d ;
: clrscr e544 jsr ;

: bufstart 4000 ;

var eof ( ram eof )

var homepos ( position at screen home )
var currlinestart

( cursor screen pos )
var curx 
var cury
0 value need-refresh
0 value insert-active

: max ( a b - c )
	2dup ( a b a b )
	< if swap then
	drop
;

: min ( a b - c )
	2dup ( a b a b )
	> if swap then
	drop
;

: editpos
	currlinestart @ curx @ +
;

: linelen
	0
	currlinestart @ ( count addr )
	begin
		dup c@ return = if
			drop 
			dup 0= if
				1+ ( never return 0, min is 1 )
			then
			exit
		then

		1+
		swap 1+ swap
	again
;

: cursor-scr-pos
	cury @ 28 *
	curx @ linelen 1- min +
	400 + ( addr )
;

: hide-cursor
	cursor-scr-pos
	dup @ 7f and
	swap c!
;

: show-cursor
	curx @ linelen 1- min curx c!

	cursor-scr-pos
	dup @ 80 or
	swap c!
;

: do-load
	load
	bufstart eof !

	begin
		read ( char )

		dup ( char char )

		eof @ ( char char *eof )
		c!

		0= if exit then

		1 eof +!
	again
;

: go-to-file-start
	0 curx !
	0 cury !
	bufstart homepos !
	bufstart currlinestart !
;

: print-line ( addr -- newaddr )
	27 >r
	begin
		dup c@ ( addr char )
		dup return = ( addr char bool )
		if
			r>
			2drop
			1+
			exit
		else
			r> dup 0> if
				1- >r
				emit
			else
				>r
				drop
			then
			1+
		then
	again
;	

: show-page
	clrscr
	0 >r
	homepos @
	begin
		print-line
		dup eof @ <
		r> 1+ dup >r 18 < and
	while
		cr
	repeat
	r>
	2drop
	7e8 c@ 7c0 c! ( status )
;

: set-status
	dup 7e8 c!
	7c0 c!
;

: init
	( disable input buffering )
	0 linebuf c! 

	( colors )
	a d021 c!
	2 d020 c!
	1 286 c!

	go-to-file-start
	20 set-status
;

: adjust-home
	begin
		cury @ 8000 and
	while
		1 to need-refresh

		ffff homepos +! ( skip first cr )
		begin
			ffff homepos +!
			homepos @ c@ return =
			homepos @ bufstart 1- = or
		until
		1 homepos +!
		1 cury +! ( cur down )
	repeat

	begin
		cury @ 17 >
	while
		1 to need-refresh

		homepos @ c@ return <> if
			begin
				1 homepos +!
				homepos @ c@ return =
			until
		then
		1 homepos +!
		ffff cury +! ( cur up )
	repeat
;

: cur-down
	currlinestart @ ( addr )
	dup c@ return <> if
		begin
			dup eof @ = if
				drop
				exit
			then
			1+ ( addr )
			dup c@ ( addr char )
			return =
		until
	then
	1+ ( newlinestart )

	dup c@ 0= if ( eof )
		drop
		exit
	then

	currlinestart !
	1 cury +!

	adjust-home
;

: cur-up
	currlinestart @ bufstart = if
		( already at top )
		exit
	then

	currlinestart @ ( addr )
	1- ( skip first return plz )
	begin
		1- ( addr )
		dup c@ ( addr char )
		return = ( addr bool )

		over ( addr bool addr )
		bufstart < ( addr bool bool )
		or ( addr bool )
	until
	( addr )

	1+
	bufstart max
	currlinestart !
	ffff cury +!

	linelen 1- curx @ min curx !

	adjust-home
;

: cur-left
	curx @
	?dup 0= if
		exit
	then

	ffff curx +!
;

: is-eof-or-return
	dup 0= swap return = or
;

: is-whitespace
	dup return = swap bl = or
;

: cur-right
	editpos c@ is-eof-or-return
	editpos 1+ c@ is-eof-or-return
	or if
		exit
	then
	1 curx +!
;

: eol
	linelen 1- curx !
;

( left, or up + eol if we're at xpos 0 )
: rewind-cur
		curx @ 0= if
			bufstart editpos <> if
				cur-up
				eol
			then
		else
			cur-left
		then
;

: sol
	0 curx !
;

: word-back
	rewind-cur
	begin
		editpos bufstart =
		editpos 1- c@ is-whitespace
		editpos c@ is-whitespace not and
		or not
	while
		rewind-cur
	repeat
;

( right, or down + sol if we're at xpos = linelen + 1 )
: advance-cur
	curx @ linelen 1- = if
		0 curx !
		cur-down
	else
		cur-right
	then
;

: word-fwd
	advance-cur
	begin
		editpos 1- c@ is-whitespace
		editpos c@ is-whitespace not and
		not
	while
		advance-cur
	repeat
;

: half-page-back
	c begin cur-up 1- dup 0= until drop
;

: half-page-fwd
	c begin cur-down 1- dup 0= until drop
;

: goto-eof ( can be much optimized... )
	begin
		editpos
		half-page-fwd
		editpos =
	until
;

: goto-start ( can be much optimized... )
	begin
		editpos
		half-page-back
		editpos =
	until
;

: status-clear
	7c0
	begin
		dup
		bl over c!
		1+
		dup 7d0 =
	until
;

: insert-start
	1 to insert-active
	[ char i ] literal set-status
;

: insert-stop
	curx @ if
		ffff curx +!
	then
	0 to insert-active
	20 set-status
;

: del-char
	curx @ 0= if exit then
	ffff curx +!
	editpos 1+
	editpos
	eof @ editpos - 1+
	ffff eof +!
	cmove
	1 to need-refresh
;

: insert-char
	editpos
	editpos 1+
	eof @ editpos - 1+
	cmove
	editpos c!
	1 curx +!
	1 eof +!
	1 to need-refresh
;

: insert-handler
	case

	14 ( backspace ) of insert-stop endof
	94 ( inst ) of del-char endof

	insert-char
	endcase
;

: main-handler
	case

	[ char i ] literal of insert-start endof

	d5 of half-page-back endof
	c4 of half-page-fwd endof
	[ char $ ] literal of eol endof
	[ char 0 ] literal of sol endof
	[ char x ] literal of 1 curx +! del-char endof
	[ char b ] literal of word-back endof
	[ char w ] literal of word-fwd endof
	[ char g ] literal of goto-eof endof
	[ char : ] literal of 
		key [ char 0 ] literal = if goto-start then
	endof

	( cursor )
	9d of cur-left endof
	11 of cur-down endof
	91 of cur-up endof
	1d of cur-right endof
	[ char h ] literal of cur-left endof
	[ char j ] literal of cur-down endof
	[ char k ] literal of cur-up endof
	[ char l ] literal of cur-right endof

	endcase
;

: main-loop
	begin
		0 to need-refresh

		show-cursor
		key
		hide-cursor

		insert-active if
			insert-handler
		else
			main-handler
		then

		need-refresh if
			show-page
		then
	again
;

: edit
	0 blink

	do-load
	
	init

	show-page

	main-loop
;

s" debug" edit
