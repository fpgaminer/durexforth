: hex 16 base ! ;
: dec 10 base ! ;
hex
: bl 20 ;
: cr d emit ;
: space bl emit ;
: / /mod swap drop ;
: mod /mod drop ;
: negate 0 swap - ;
: bg d020 c! ;
: literal immed ' lit , , ;
: '(' [ char ( ] literal ;
: ')' [ char ) ] literal ;
: '"' [ char " ] literal ;
: '.' [ char . ] literal ;
: ':' [ char : ] literal ;
: ';' [ char ; ] literal ;
: [compile] immed word find >cfa , ;
: ['] immed ' lit , ;
: :noname 0 create here @ 20 c, docol , ] ;
: if immed ' 0branch , here @ 0 , ;
: then immed dup here @ swap - swap ! ;
: else immed ' branch , here @ 0 , swap dup here @ swap - swap ! ;
: green 5 bg ;
: yellow 7 bg ;
: begin immed here @ ;
: until immed ' 0branch , here @ - , ;
: again immed ' branch , here @ - , ;
: while immed ' 0branch , here @ 0 , ;
: repeat immed ' branch , swap here @ - , dup here @ swap - swap ! ;
: unless immed ' not , [compile] if ;
: recurse immed latest @ >cfa , ;
: incbg d020 c@ 1+ d020 c! ;
: decbg d020 c@ 1- d020 c! ;
: ( immed begin key ')' = until ;
: cc begin incbg again ;
: nip ( x y -- y ) swap drop ;
: tuck ( x y -- y x y ) dup rot ;
: pick ( x_u ... x_1 x_0 u -- x_u ... x_1 x_0 x_u ) 1+ 2 negate * dsp@ + @ ;
: <> ( n -- b ) = not ;
: > ( n -- b ) swap < ;
: 0> ( n -- b ) 0 > ;
: <= ( a b -- c )
	2dup ( a b a b )
	< ( a b < )
	rot ( < a b )
	= ( < = )
	or
;
: spaces ( n -- ) begin dup 0> while space 1- repeat drop ;
: ? ( addr -- ) @ . ;
: tell 
	dup c@ ( get strlen )
	begin 
		swap 1+ ( inc strptr )
		dup c@ emit ( print char )
		swap 1- ( dec strlen )
		dup 0= 
	until
	2drop
;
: s" immed ( -- addr len )
	state @ if
		' litstring ,
		here @ ( save addr of length byte on stack )
		0 c, ( dummy length - we don't know what it is yet )
		begin
			key
			dup '"' <>
		while
			c,
		repeat
		drop
		dup
		here @ swap -
		1- ( subtract to compensate for length byte )
		swap c!
	else ( immediate mode )
		here @
		begin
			key
			dup '"' <>
		while
			over c!
			1+
		repeat
		drop
		here @ -
		here @
		swap
	then
;
: ." immed ( -- )
	state @ if ( compiling? )
		[compile] s"
		' tell ,
	else
		( in immediate mode, just read and print chars )
		begin
			key
			dup '"' = if
				drop
				exit
			then
			emit
		again
	then
;

: case immed 0 ;
: of immed ' over , ' = , [compile] if ' drop , ;
: endof immed [compile] else ;
: endcase immed ' drop , begin ?dup while [compile] then repeat ;

: forget word find dup @ latest ! here ! ;

: ?hidden
	1+ 1+ ( skip link ptr )
	c@
	40 and
;

: ?immed
	1+ 1+ ( skip link ptr )
	c@
	80 and
;

: cfa>
	latest @ ( start at latest dictionary entry... )
	begin
		?dup ( while link ptr != 0 )
	while
		2dup swap ( cfa curr curr cfa )
		< if ( current dictionary entry < cfa ? )
			nip ( leave it on stack )
			exit
		then
		@ ( follow link ptr back )
	repeat
	drop
	0
;

: +! ( num addr -- ) 
	dup @ ( num addr val )
	-rot + ( addr val num )
	swap ( newval addr )
	!
;

: -! ( num addr -- ) 
	dup @ ( num addr val )
	-rot - ( addr val num )
	swap ( newval addr )
	!
;

: >dfa >cfa 1+ 1+ 1+ ;

: id.
	1+ 1+ ( skip over link ptr )
	dup c@
	3f and ( fix me... should a constant with length mask )
	begin
		dup 0>
	while
		swap 1+
		dup c@
		emit
		swap 1-
	repeat
	2drop
;

: allot ( n -- addr )
	here @ ( n val )
	swap ( val n )
	here +!
;

: cells ( n -- n ) dup + ; ( 2* )

: var
	1 cells allot
	word create
	20 c,
	docol ,
	' lit ,
	,
	' exit ,
;

: value ( n -- )
	word create
	20 c, docol ,
	' lit , , ' exit ,
;

: to immed ( n -- )
	word find >dfa 1+ 1+
	state @ if
		' lit , , ' ! ,
	else
		!
	then
;

( x +to val adds x to val )
: +to immed
	word find >dfa 1+ 1+
	state @ if
		' lit , , ' +! ,
	else
		+!
	then
;

: words
	latest @
	begin
		?dup
	while
		dup ?hidden not if
			dup id. space
		then
		@
	repeat
	cr
;

( c a b within returns true if a <= c and c < b )
: within
	rot
	over
	<= if
		> if
			1
		else
			0
		then
	else
		2drop
		0
	then
;

: dump ( addr len -- )
	swap fff8 and swap

	begin
		?dup ( while len > 0 )
	while
		over . space

		2dup ( addr len addr len )
		1- 7 and 1+ ( addr len addr linelen )
		begin
			?dup ( while linelen > 0 )
		while
			swap ( addr len linelen addr )
			dup c@ ( addr len linelen addr byte )
			c. space ( print byte )
			1+ swap 1- ( addr len linelen addr -- addr len addr+1 linelen-1 )
		repeat
		drop ( addr len )

		( print in petscii... )
		2dup 1- 7 and 1+
		begin
			?dup
		while
			swap
			dup c@
			dup 20 5e within if
				emit
			else
				drop '.' emit
			then
			1+ swap 1-
		repeat
		drop ( addr len )
		cr

		dup 1- 7 and 1+ ( addr len linelen )
		dup
		rot
		-
		rot
		+
		swap
	repeat
	drop
;

: locate
	word find
;

: see
	word find
	here @
	latest @
	begin
		2 pick
		over
		<>
	while
		nip
		dup @
	repeat
	
	drop
	swap ( end-of-word start-of-word )

	':' emit space dup id. space
	dup ?immed if ." immed " then

	>dfa ( get data addr )

	begin
		2dup >
	while
		dup @

		case
		' lit of
			2 + dup @ .
		endof
		' litstring of
			[ char s ] literal emit '"' emit space
			2 + dup c@ 
			swap dup tell
			'"' emit space
			+ 1-
		endof
		' ' of
			[ char ' ] literal emit space
			2 + dup @
			cfa>
			id. space
		endof
		' branch of
			." branch ( "
			2 + dup @ .
			." ) "
		endof
		' 0branch of
			." 0branch ( "
			2 + dup @ .
			." ) "
		endof
		' exit of
			2dup
			2 +
			<> if
				." exit "
			then
		endof
			( default )
			dup
			cfa>
			id. space
		endcase
		2 +
	repeat
	';' emit cr
	2drop
;

locate dump 20 dump
see dump
